\section{Introduction}
The prospering IoT applications constantly proposes higher requirements to security where cryptography plays an important role. Among all prerequisite of implementing cryptographic primitives on these IoT devices, a reliable Random Number Generator (RNG) is critical as it is required in most cryptographic algorithms. In practice, a RNG typically involves a Pseudo Random Number Generator (PRNG) seeded by a high entropy physical source.

In 2013, Texas Instruments (TI) launched a new System-on-chip (SoC)  CC2538\cite{CC2538}, featuring integrity, 802.15.4 support and feasible for security applications with multiple cryptographic hardware accelerator. It was not long before this product drawed the community attention, for example, Contiki and OpenWSN soon released their support to CC2538 within the same year. As of writing this paper, the chip remains in the suggested list for Zigbee and 6LoWPAN solution on TI's website\cite{ZigbeeProducts}\cite{6LowPANProducts}.

However, despite all the cryptographic hardware support, CC2538 does not have a RNG dedicated for cryptographic applications; instead, the user manual suggested to use a 16 bit Linear Feedback Shift Register (LFSR) as a PRNG where the seed generated by the Radio Frequency (RF) module sampling from the radio noise. It turns out such RNG is catastrophic for cryptographic applications running on these chips as:
\begin{enumerate}
	\item The PRNG has only 16 bit entropy which can be easily predicted.
	\item Sampling the seed from RF induces the potential for an adversary to remotely interfere the seeding procedure through jamming signals.
\end{enumerate}

In this paper, we first revised why such PRNG design is a bad idea explaining how this can be exploited to completely break DTLS handshake with ECDHE and ECDSA cipher suites. Then we present a study to its method of sampling the random seed from radio noise and finally demonstrate how the seed could be biased through radio jamming. 

Experiments in this paper are performed on Contiki OS\cite{Contiki} release version 3.0. The related source code can be accessed at \cite{prngtest}.

We begin in \Cref{ContikiDriverIssue} with some Contiki RNG driver issues for CC2538. \Cref{LFSR} revises why using a 16 bit LFSR as PRNG is a bad practice and we show how this design flaw can be exploited to break DTLS in \Cref{BreakDTLS}, before reviewing the problem in \Cref{PRNGReflection}. In \Cref{Seed} we explain how CC2538 samples the radio noise into random seed and then we demonstrate how it can be biased by jamming signals in \Cref{Jamming}. Finally we conclude the paper in \Cref{Conclusion}.

\section{Related Work}
The design flaw of using a 16 bit LFSR as PRNG has been reported by \cite{SmartMeterBlog}\cite{CC2530PRNG} on CC2430\cite{CC2430Manual} and CC2530\cite{CC2530Manual} which are the predecessors of CC2538 in the SimpleLink\cite{SimpleLink} series and adopted the same RNG design. The blogs reported the flaw and warned that it could easily be exploited to break the Z-Stack library\cite{ZStack} and Smart Energy Profile ECC in many Smart Meter applications.

With respect to using jamming signal to bias the seed, this is the first substantial work that has been done on this subject to our knowledge. 

\section{Contiki Driver Issue}\label{ContikiDriverIssue}
As of writing this paper,  the CC2538 RNG driver in the current Contiki release version (release-3.0) has some coding issues, including:
\begin{itemize}
	\item Reading the LFSR without ready check.
	\item Lack of validity check when reading random bits from RF module.
	\item A coding mistake that drops the Most Significant Bit (MSB) and leaves the Least Significant Bit (LSB) to be constantly $0$ in the seed.
\end{itemize}

We have modified the code and fixed these issues in our experiments. The issues are reported to the code authors and are expected to be fixed in future Contiki release.

Another issue in the driver is that the CC2538 User's Guide\cite{CC2538Manual} suggests only to use the lower byte (8 bits) as a random number but the driver actually used 16 bits in the LFSR. However, this coding mistake does not affect our result, as will be explained in  later sections.