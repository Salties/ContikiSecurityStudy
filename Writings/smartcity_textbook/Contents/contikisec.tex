\chapter{Contiki OS}
Assuming this is the structure...

\section{Securities in Contiki OS}

%Though these paragraphs might not be necessary...
%The Contiki OS has some component implemented in the security aspect. Several factors need to be taken into account when selecting security components to be used in the application, including:
%
%\begin{itemize}
%\item The trade-off between security and performance, such as the overhead of bandwidth, energy consumption, etc. Usually a higher level of security comes with more reduction in performance.
%
%\item The capability of the potential adversary. For example, passive eavesdropping is a common type of attack in a Wireless Sensor Networks scenario. Further more, if the device is exposed in an open environment then side channel attacks\footnote{Attacks that exploit physical metadata, e.g. power consumption, timing information, etc.} need also be taken into consideration. In some cases legitimate users can also considered malicious,  say users who try to tamper with their smart meter readings.
%
%\item The hardware and software setup of the platform. For instance, the AES coprocessor provided in CC2538 platform provides a great performance in both computation time and energy consumption; the latency induced by ContikiMAC can make attacks exploit the packet timing information more difficult.
%\end{itemize}
%
%After all, due to the constrained resources and variant applications, implementing security protocols poses great difficulties in Contiki OS as well as other embedded operating systems.
%
%In this section, we will cover two major security component that has been implemented on Contiki OS, Link Layer Security and DTLS.

Implementing security protocols poses great difficulty in IoT devises due to the constrained resources and variant applications. In this section, we will cover two security components that has so far been implemented on Contiki OS, namely LLSEC and DTLS respectively.

\subsection{LLSEC: noncoresec}
Link Layer Security, or LLSEC, is a security mechanism at Link Layer level. In Contiki OS, noncoresec is the 802.15.4 security instantiation that has been implemented. Its design goal is to provide:
\begin{itemize}
\item Data confidentiality over MAC layer payload.
\item Authenticity and integrity over MAC header and MAC payload.
\end{itemize}

noncoresec is disabled by default. When enabled, different security level can be configured from no security, to encryption / authentication only, then to full encryption and authentication.

To be more specifically, noncoresec has the following implemented:

\begin{description}
\item[\textbf{Block Cipher}] \hfill \\
As specified by 802.15.4 specification, AES\footnote{Advanced Encryption Standard\cite{AES}}-128 is chosen as the underlying block cipher. Contiki OS implements a software AES-128, but on those platforms with an AES coprocessor, such as CC2538, it can be switched to use the hardware implementation instead. The benefit for doing so is to have a better time and energy efficiency as well as to gain potential protections against side channel analysis attacks.

\item[\textbf{Mode of Operation}] \hfill \\
Also specified by 802.15.4 specification, the AES block cipher is used in CCM* mode, i.e. CTR mode with CBC-MAC. The asterisk symbol implies the additional support of security levels and additional requirement to encode the security level into the nonce.

\item[\textbf{Key Management}] \hfill \\
 A hard coded AES-128 key is shared among the whole network in LLSEC. This effectively means that the same key will be used for all incoming and outgoing data frames on every node.
 
\item[\textbf{Replay Protection}] \hfill \\
noncoresec has implemented the replay protection by comparing the received frame counter with the last frame counter from the same source.
\end{description}

Therefore in general, noncoresec has the following benefits:
\begin{itemize}
\item It prevents an eavesdropper from seeing the plaintext of MAC Layer payload.
\item It prevents illegal nodes from joining the network, as nodes without knowledge of the network shared key cannot forge a message.
\item It can be implemented efficiently on most platforms, especially with hardware support.
\item Multicast and broadcast is supported by the nature of 802.15.4.
\end{itemize}

However, the following factors should also be taken into concern when adopting noncoresec into the security measures:
\begin{itemize}
\item Lack of flexibility. This is mostly due to the fact that the key is hard coded.
\item Fixed key. There is yet no key updating scheme implemented. 
\item Reused nonce. Since in CCM mode, the difference of two ciphertext is exactly the same of their according plaintext and knowing that can lead to breach of data confidentiality in many cases. The reuse may occur when the 4 bytes frame counter rounds up, or when the devices reboots which resets the frame counter back to $0$.
\item Authentication only 802.15.4 frame header. The 802.15.4 frame header is not encrypted and thus can be seen by an eavesdropper.
\end{itemize}

More discussion of 802.15.4 security can be found in \cite{802154sec}, with respect to more key and nonce management schemes and integrity protection schemes.

\subsection{DTLS: tinydtls}
DTLS is derived from the widely used TLS protocol on Internet. As of TLS, DTLS also provides encryption and authentication between two nodes. It is currently adopted as the security measure of CoAP.

The main difference between TLS and DTLS is that TLS is based on TCP whilst DTLS is based on UDP, where the later one is more adapted to IoT applications. In addition, DTLS also provides a simple reliable transmission mechanism as a result for providing data integrity.

DTLS is a stateful session based protocol. This implies that:
\begin{itemize}
\item A handshake must be performed between two nodes before any data can be transmitted.
\item Different session keys are derived for each session during the handshake.
\end{itemize}

The nodes actively initiates and passively accepts a session are referred as client and server respectively.

In Contiki OS, DTLS is provided by a third party implementation named tinydtls\cite{tinydtls}. The current version of tinydtls supports two cipher suites:

\begin{description}
\item[\textbf{TLS\_PSK\_WITH\_AES\_128\_CCM\_8}] \hfill \\
The DTLS server and client uses a pre-shared master secret value. The session key, an AES-128 key, is then derived from alongside with two random values exchanged during the handshake. The application data is then encrypted with AES-128 block cipher in CCM mode with 8 byte authentication tag. No certificate verification is performed when using this cipher suite.
\item[\textbf{TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CCM\_8}] \hfill \\
When this cipher suite is used, the DTLS server and client performs an ECDHE key agreement using public keys and parameters signed by ECDSA. The session key, an AES-128 key, is an output of ECDHE key agreement. The data is then encrypted with AES-128 in CCM mode with 8 byte authentication tag thereafter.
\end{description}

Comparing to LLSEC, DTLS has several advantages:
\begin{itemize}
\item \textbf{Flexibility and scalability}. DTLS is built upon UDP, an application can therefore choose whether do or not do use encryption to avoid overhead. It also allows multiple connections being established between two nodes, or different parameters being used between different nodes. Further more, a DTLS connection can be established dynamically between two nodes that are not linked locally, in contrast to LLSEC that only works between nodes that are directly connected.
\item \textbf{Dynamic key management}. DTLS connections are established during running time, it is possible for the applications to dynamically update the keys on desire by utilising the key updating mechanisms of DTLS.
\item \textbf{Interoperability}. DTLS is implemented above Transportation Layer (TCP/UDP) and therefore Physic Layer and Link Layer details eventually becomes transparent to the application. This feature is significantly important when the two ends of DTLS connection are located in different types networks, such as accessing a wireless sensor node in 6LowPAN network from a desktop connected to Internet. 
\item \textbf{End to end security}. Since session keys are generated independently for each DTLS session, the corruption of one node in the network does note breach the data confidentiality of other nodes. In comparison, the breach of the network shared key of noncoresec will directly result into revelation of all plaintext among the whole network.
\item \textbf{Additional reliability}. Even though UDP is unreliable, DTLS implements a simple retransmission and windows mechanism in order to provide data integrity.
\end{itemize}

Several drawbacks of using DTLS need also be noticed:

\begin{itemize}
\item \textbf{Additional resource requirement.} e.g. compiling with tinydtls library on CC2538 platform costs about 80KB additional code size. It also requires more memory during running time as DTLS is a stateful protocol and thus the state of each session needs to be preserved in memory.
\item \textbf{Bandwidth overhead.} The DTLS header consumes about 30 bytes of bandwidth for each packet. Considering the fact that the the minimum MTU\footnote{Maximum Transmission Unit} required by 6LowPAN is only 127 byte; the 30 byte overhead can be very impactful to some applications. 
\item \textbf{Exceeding length of handshake packets.} DTLS handshake message are usually longer than usual data packets. In the specific cases of tinydtls, that is\\ TLS\_PSK\_WITH\_AES\_128\_CCM\_8 \\
and \\
TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CCM\_8, the longest handshake packets are about 150 and 200 bytes respectively. This becomes problematic with low bandwidth platforms, such as Telos B.
\item\textbf{Low performance.} Some cryptographic operations, such as curve computations, takes extraordinary long time to perform. Take  CC2538 for instance, a \\ TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CCM\_8 handshake takes minutes (about 80s for one side) to complete. This issue can aggravate to dis-functioning in some cases combined with other factors. For example, when a user tries to access a sensor node through CoAPS\footnote{CoAP with DTLS}, the handshake will likely fail with a high probability. The reason is that the desktop side completes its computation immediately and thus will rapidly send out multiple exceedingly long handshake packets. Whereas the sensor side cannot handle the packets accordingly and some packets will eventually be dropped due to the constrained buffer of sensor node.
\item \textbf{No multicast support (yet).} As of TLS, DTLS is designed to protect one-to-one communication and not being able to cooperate with IPv6 multicast will result into great reduction of functionality, e.g. the multicast feature of CoAP. Some attempts\cite{multicast1}\cite{multicast2} has been made, but there is yet a concrete solution to this problem.
\end{itemize}

\subsection{Other security concerns}
The security components we described above in Contiki OS mainly focus on encryption and authentication of data. However, they do not provide any countermeasure against side channel attacks. For example, neither LLSEC nor DTLS provides any mechanism to hide the meta data of packets, such as packet length, packet headers and timing information, which can be potentially exploited by traffic analysis attacks\cite{ta1} \cite{ta2} \cite{ta3}. 

\subsection{Conclusion}

\begin{thebibliography}{99.}
\bibitem{AES} NIST (2001) Announcing the ADVANCED ENCRYPTION STANDARD (AES). Available via\\
\url{http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf}

\bibitem{802154sec} Sastry N, Wagner D (2004) Security Considerations for IEEE 802.15.4 Networks. Proceedings of the 3rd ACM Workshop on Wireless Security 32--42

\bibitem{tinydtls} tinydtls. \\ 
\url{http://tinydtls.sourceforge.net/}

\bibitem{multicast1} DICE Working Group (2015) DTLS-based Multicast Security in Constrained Environments
 draft-keoh-dice-multicast-security-08 (Expired Internet-Draft (individual)). Available via\\
\url{https://tools.ietf.org/pdf/draft-keoh-dice-multicast-security-08.pdf}

\bibitem{multicast2} Marco Tiloca (2014) Efficient Protection of Response Messages in DTLS-Based Secure Multicast Communication. Proceedings of the 7th International Conference on Security of Information and Networks, Glasgow, Scotland, UK, September 9-11, 2014 Page 466

\bibitem{ta1} Shuo Chen, Rui Wang, XiaoFeng Wang and Kehuan Zhang (2010) Side-Channel Leaks in Web Applications: {A} Reality Today, a Challenge Tomorrow. 31st {IEEE} Symposium on Security and Privacy, S{\&}P 2010, 16-19 May 2010, Berleley/Oakland, California, {USA} Page 191--206

\bibitem{ta2} Luke Mather and Elisabeth Oswald (2012) Pinpointing side-channel information leaks in web applications. J. Cryptographic Engineering 2:3 161--177

\bibitem{ta3} Dyer, Kevin P. and Coull, Scott E. and Ristenpart, Thomas and Shrimpton, Thomas (2012) Peek-a-Boo, I Still See You: Why Efficient Traffic Analysis Countermeasures Fail. Proceedings of the 2012 IEEE Symposium on Security and Privacy 332--346
\end{thebibliography}