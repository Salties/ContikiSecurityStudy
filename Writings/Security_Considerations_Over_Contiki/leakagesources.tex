\chapter{Potential Leakage Sources}

In this chapter, we discuss the potential leakage sources in the experimental environment we have set up in \Cref{Chp: Experiment Setup}. 

\section{A Review of Review}
%What is ``Information''

The first and fundamental question that must be clarified in this project is: what is ``information''?

If we look at those attacks described in \Cref{Chp: Literature Review}:

\begin{itemize}
	\item In literatures about the flaws in implementations of algorithms and protocols, ``information'' is the plaintext, usually represented as a numerical value, such as \cite{802154sec} \cite{rfc7457} \cite{CompressionRatioAttack} \cite{PaddingOracle}. Or it could be the secret key materials in many cryptographic side channel attack literatures, such as \cite{DPA}.
	\item In Traffic Analysis Attacks against web applications, ``informaiton'' is the user input, such as \cite{PinpointWeb} \cite{SearchAttack}, or the content of websites such as \cite{WebSideChannel}.
	\item When we talk about website fingerprinting such as \cite{WebsiteFingerprint} \cite{Peekaboo} and \cite{PClassifier}, ``information'' is the identity of websites. 
	\item The category only gets even more messy and trivial when we look at other Traffic Analysis Attacks, such as the spoken language and phrases in \cite{VoIPLanguage} and \cite{VoIPPhrases}, user event and OS of Apple product in \cite{AppleMessage} or even the ambient change and motion event in \cite{Video}.
\end{itemize}

``Information'' is always a relative concept to ``application'', so is ``leakage''. 

In this report, we are interested on information leakages with regard to the following attributes:

\begin{description}[style=nextline]
	\item[Content and Size of Application Data]
	The implication of Application Data varies on different applications.
	
	\item[Cryptographic Key]
	This represents the corresponding key materials in the security measure.
	
	\item[Application Code Routine]
	This implies the application specific feature.
	
	\item[Network Topology]
	This implies how Sensor Nodes connect to each other.
\end{description}

Notice that the information leakage is highly application specific. In this report, we discuss only the applications described in \Cref{Sec: Applications}. 

\section{Observables}

Generally speaking, observables in captured traffic can be classified into two categories:
\begin{enumerate}
	\item Implicit observables. These imply the data an adversary can access without inspecting the content of packets.
	\item Explicit observables. These imply the data given in the unencrypted part of packets.
\end{enumerate}

\subsection{Implicit Observables}

There are mainly two observables we concern in this category:

\begin{description}[style=nextline]
	\item[Packet Size] 
	This refers to the size (or length) of a packet. This value is also explicitly included in the packet headers.
	
	\item[Packet Timing]
	This refers to the time being sent of a packet. 
\end{description}

In addition to Packet Size and Packet Timing, there are some other implicit observables we do not concern in this report:

\begin{description}[style=nextline]
	\item[Presence of Packets]
	Apparently, the presence of a packet implies the existence of a Sensor Node device, which is kind of an information leakage. However, we do not take this into account. We assume the adversary has prior knowledge of the existence of WSN.
	
	\item[RSSI]
	Receive Signal Strength Indicator, RSSI, indicates the RF signal strength from a Sensor Node. Practically speaking, by measuring the RSSI of frames sent from a specific source MAC address, the adversary is capable to reveal the physical location of Sensor Node. In this report we do not take RSSI into account as its physical character is beyond the scope of this project. We assume the adversary has prior knowledge of the geographic information of the Sensor Nodes.
\end{description}

The implicit observables are commonly accessible in all scenarios in our experiments.

\subsection{Explicit Observables}

We have explained in \Cref{Chp: Experiment Setup} that there are two security measures implemented on our platform, namely noncoresec and DTLS. Referring to \Cref{Chp: Building Blocks}, these measures are implemented at different layers. The observables are therefore different for noncoresec and DTLS. 

\subsubsection{noncoresec}

As explained in \Cref{Subsec: 802.15.4 Security Implementation in Contiki}, noncoresec is the 802.15.4 Security implementation on Contiki. When noncoresec is enabled, all captured frames is in the form we explained in \Cref{Subsec: 802.15.4 MAC} and \Cref{Subsec: 802154 Sec}. The MAC Layer Header is the only observable part of a packet.

We stated in \Cref{Subsec: noncoresec in experiment} that we always use highest Security Level of 802.15.4 Security; therefore:
\begin{itemize}
	\item MAC Payload is always authenticated and encrypted in AES-128 with CCM* mode.
	\item Security Level is constantly 0x7.
	\item Key Strategy is constantly 0x0 as noncoresec does not implement any key management.
\end{itemize}

As a result of MAC Payload being authenticated and encrypted, 
\begin{itemize}
	\item The adversary cannot join the 6LoWPAN network as we have explained in \Cref{Subsec: noncoresec in experiment}.
	\item The adversary cannot distinguish an IPv6 packet and an ICMPv6 packet by simply looking the contest as it is encrypted. 
\end{itemize}

The IPv6 packets effectively are the packets with Application Data. ICMPv6 packets in our experiments are basically RPL messages.

\subsubsection{DTLS}

As explained in \Cref{Chp: Building Blocks}, when DTLS is used, the explicit observables are: 

\begin{itemize}
	\item MAC Header as explained in \Cref{Subsec: 802.15.4 MAC}.
	
	\item Compressed IPv6 Header as explained in \Cref{Subsec: 6LoWPAN Adaptation Sub Layer}, \Cref{Subsec: IPv6 Data Packets} and \Cref{Subsec: ICMPv6}.
	
	\item UDP Header as explained in \Cref{Subsec: UDP}.
	
	\item DTLS Header as explained in \Cref{Subsec: DTLS}.
\end{itemize}

Since DTLS is built on Application Layer, therefore it does not impose any setting to the lower layer headers. The only exception is the Protocol Version of DTLS Header since tinydtls supports only DTLS version 1.2, therefore Protocol Version is constantly \{0xfe, 0xfd\}, i.e. \{0xff, 0xff\} - \{0x01, 0x02\}.

\subsection{Traces}

Before discussing the ``traces'' in WSN applications, as a comparison, we review the different definition of ``traces'' in the literatures we reviewed in \Cref{Chp: Literature Review}:

\begin{itemize}
	\item In literatures about Traffic Analysis Attacks against web applications\cite{WebSideChannel}\cite{PinpointWeb}\cite{SearchAttack}, a ``trace'' refers to the continuous\footnote{We would argue that the term ``continuous'' is ambiguous; nevertheless it is the best definition we can thought of.} packets triggered by an user input.
	\item In Website Fingerprinting literatures\cite{WebsiteFingerprint} \cite{HClassifier} \cite{PClassifier} \cite{Peekaboo}, a ``trace'' refers to the continuous packets that triggered by a browser requesting a website.
	\item Other attacks use more specific application dependent definitions of a ``trace''. \cite{VoIPLanguage} and \cite{VoIPPhrases} defined a ``trace'' to be the continuous packets during a VoIP conversation. \cite{Video} defines it to be the continuous packets during a video conversation. \cite{AppleMessage} does not even use the term ``trace'' at all\footnote{Actually it did used once as a verb equivalent to ``track''.} as it only analyses a single packet.
\end{itemize}

Practically, the ``trace'' of an Internet application usually can be isolated by filtering packets belong to the same TCP connection, i.e. TCP packets with the same entities\footnote{An entity is the combination of an IP address and a port}. However, we cannot apply the same method on many WSN applications due to the change of protocol suite. Further more, the WSN applications perform Machine To Machine, M2M, communication which has much less external intervention, makes it harder to group packets into ``traces''.

Another factor needs to be taken into concern is the different characteristics of WSN applications and Internet applications. As a result of resource constrained environment, that WSN application designs tend to be simple and stateless, that is to say the computation on the Sensor Node needs to be simple enough to be performed on such devices and data transmission is minimised. From this aspect, we argue that the simple applications we described in \Cref{Sec: Applications} captured these characteristics of WSN applications.  

Therefore in our analysis we define a trace to be the packets in one data exchange routine. Indeed, there are typically only two packets in a trace. The first one requesting a sensor reading on a Sensor Node, and the second one is the response from the Sensor Node to the requester. However, in other applications the form of traces may vary. For example, in the broadcast keyllsec application in \Cref{application}, or an application using OBSERVE option as we explained in \Cref{Subsec: CoAP}, there can be responses without a request, which leaves only one packet in a trace.

\section{Theoretical Analysis}





