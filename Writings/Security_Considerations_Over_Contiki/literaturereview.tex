\chapter{Preliminaries:\\ Literature Review} \label{Chp: LiteratureReview}

In this chapter we review the literatures with respect to security in WSN. We roughly categorise the literatures into three aspects we consider to be mostly relevant to this project:

\begin{enumerate}
	\item Protocol and implementation flaws
	\item Traffic analysis techniques
	\item Information leakage detection
\end{enumerate}

As introduced in \Cref{Chp: Building Blocks}, many 6LoWPAN protocols are derived from Internet. Therefore in this report we also refer to existing attacks on Internet that could potentially be applied in WSN.

\section{Protocol and Implementation Flaws}

%In this section we focus on protocol suite described in \Cref{Tbl: Summary of WSN Building Blocks}, namely `'802.15.4 + 6LoWPAN + CoAP''.

%Security consideration of 802.15.4
\subsection{802.15.4 PHY and MAC}
\cite{802154sec} reviews the design flaw in 802.15.4 Security. First of all, the nonce reuse may happen due to the same key used in different entry, or power failure on device. Secondly, the key management also needs to be improved. The ACL does not support group key, using a default ACL entry for network shared key is incompatible with replay protection. Finally, the Security Levels without authentication should not be used. Allowing an adversary to forge messages potentially breaches the data confidentiality in many applications. It also allows the adversary to launch a Denial of Service, DoS, attack by spoofing a frame with the maximum Frame Counter which eventually triggers the replay protection on later legitimate frames. In addition, the lack of security in ACK frames can also be exploited in a jamming DoS attack to forge false ACKs to prevent retransmission.

\subsection{6LoWPAN}
%6LoWPAN Fragmentation Attack
6LoWPAN fragmentation attack\cite{6lpFragAtk} exploits the unauthenticated packet fragments in 6LoWPAN. An adversary within the network can spoof a fragment of IPv6 packet causing the receiver to drop the corrupted  packet, or she can send a forged initial fragment requesting the victim node to allocate unnecessary memory which eventually results into legal packets being dropped. They propose two countermeasures to prevent these fragmentation attacks. The first countermeasure is to add chained integrity tag into each fragment to prevent the spoofed fragments. The second countermeasure is to use a more sophisticated memory management scheme that does not allocate memory until an actual fragment is received.

%6LoWPAN DoS
\cite{6lpRplAtk} gives an overview of attacks that targets 6LoWPAN and RPL. These attacks mainly results into malfunctioning of the WSN. In Sinkhole Attack\cite{Sinkhole}, the malicious node sends false RPL message to direct all messages to itself. Sinkhole Attack can further extend to Blockhole Attack\cite{Blackhole} by dropping all packets silently, eventually disables the communication of network. Wormhole Attack\cite{Wormhole} works by replaying legitimate RPL messages at an illegal location, causing confusion in the DODAG structure and therefore disrupts the communication. A malicious node launching Hello Flood Attack repeatedly broadcasts a Hello, refers to DIS, message, triggers its neighbour to respond with DIO messages and eventually depletes the battery of victims.

\subsection{TLS and DTLS}
\cite{rfc7457} summarises known attacks  against TLS and DTLS. Due to the constrained resources in WSN devices, implementations tend to support only  minimum protocols and cipher suites. We omit some of these attacks as they do not seem to be feasible in WSN environments.

\subsubsection{Compression Ration Attacks}

%Compression Ratio Attack
Compression Ratio Attack is proposed in \cite{CompressionRationAttack} which is a type of plaintext recovery attack that exploits the length difference of compressed ciphertext. This type of attack has been realised by the CRIME\cite{CRIME} Attack against TLS compression, and TIME\cite{TIME} Attack and BREACH\cite{BREACH} Attack against HTTP compression respectively. In this type of attacks, the plaintext constitutes of two parts. The first part is the explicit part which is known or even controlled by adversary. The second part is the implicit part which is unknown secret to the adversary . The first observation is that the plaintext is compressed before encrypted, since the encrypted ciphertext should appears random and can be hardly compressed. The second observation is that the more repetitive patterns in the plaintext the more bytes it will be compressed and hence results into more shrink in the length of ciphertext. The two factors combined together gives the adversary an oracle to guess the implicit part of plaintext through the explicit part, as a correct guess in the explicit part corresponds to a higher compression ratio in ciphertext.\cite{CompressionCountermeasure} proposed two countermeasures to this types of attacks. The first one is to compress the explicit part and implicit part separately. This approach completely disables the compression oracle but is not generally applicable as the explicit part and implicit part are application dependent. The second countermeasure is to use a fixed dictionary in compression. This countermeasure prevents such attacks since the explicit part no longer affects the compression ratio of the secret, but this method drastically degrades the performance of compression. Even though the protocol suite we introduced in \Cref{Chp: Building Blocks} does not include any of such compression\footnote{The IPv6 header compression can be considered to be using a fixed common dictionary.} methods, this attack should still be taken into account, as compressions are very likely to be used in WSN applications due to their low bandwidth nature. 

\subsubsection{Padding Oracle Attacks}

%Lucky 13
Lucky Thirteen Attack\cite{Lucky13} is a Padding Oracle Attack\cite{PaddingOracle} on DTLS. The Padding Oracle Attack targets cipher suites with padding and MAC-then-Encrypt in CBC mode of operation. Denote $C_n$ to be the last block of the $n$-blocks ciphertext. During a CBC decryption, $C_n$ is decrypted by the block cipher first and then XORed with $C_{n-1}$ resulting into the plaintext $P_n$. $P_n$ is then first checked with correct scheme padding, and then the MAC. In older version of SSL/TLS, failure at different steps returns different error messages. The padding oracle refers to such a source that distinguishes the difference between these errors. Such difference in error messages can therefore exploited by an adversary who is capable of asking the decryption of chosen ciphertexts. To be more specifically, for a target ciphertext, the adversary first modifies the second-last block of ciphertext from the first byte forward. These modifications will be directly XORed to the plaintext, triggering a MAC error until the padding is affected which triggers a padding error instead. This exposes the position of the last byte of plaintext in $C_n$. Since the padding values are predictable, the adversary then modify the byte in $C_{n-1}$ which corresponds to the last byte of plaintext in $C_n$ alongside with the bytes corresponds to the padding. The aim of this modification it to trick the decryption process to treat the modified last byte of plaintext as part of the padding. Once a MAC error is returned, which indicates the ciphertext has passed the padding check, the adversary can soon learn the last byte of plaintext by XORing the modified difference with the predicted padding value. The process can be carried on backward byte by byte to recover the full plaintext.  Later versions of SSL/TLS patched this vulnerability by using an unified error message on both check failures, but further study\cite{Lucky13} shows that such padding oracle can still be constructed by observing the slight timing difference of both errors. Specifically in the case of DTLS, although the protocol by nature does not provide the error messages, the timed padding oracle can still be constructed through observing the response time for a DTLS Heartbeat message. However, such attack is not yet feasible in our platform as the protocol suite / implementation in our platform does not employ any cipher suite with CBC mode.

%Smartgrid Dump Crypto


\section{Traffic Analysis}

Traffic Analysis is a family of attacks on Internet. Security protocols, such as SSL/TLS,  provide authenticity, integrity and confidentiality protection to the application data, but many side channel information are usually overlooked by the protocols, including headers of unencrypted protocols, timing information of packets and length of packets. 

Studies, \cite{WebSideChannel}\cite{PinpointWeb}\cite{Peekaboo} among the others, showed that these side channel information can indeed be exploited by an adversary to reveal some information that are intended to be hidden by the security protocols, such as contents in the encrypted packets or end identities of a communication. These side channel attacks using the observable features of traffic are generally called Traffic Analysis Attacks.

Comparing cryptographic attacks, Traffic Analysis are commonly different in a way such that:
\begin{itemize}
	\item Traffic Analysis does not try to break the cryptographic primitives, as we can see later in this section. 
	\item Traffic Analysis Attacks are usually application specific. As we can see later in this section, most Traffic Analysis Attacks are targeted at a specific application, either a website, a search engine or a text message service, etc.
	\item The target usually assumes a publicly known smaller plaintext space, instead of the arbitary message in many cryptographic context. For example, one attack in \cite{WebSideChannel} targets a selection list in a website with only tens of options,  \cite{Peekaboo} discusses attacks in a closesd world, i.e. an idea world with only hundreds or thousands websites.
	\item Traffic Analysis are hard to prevent, as shown in \cite{Peekaboo} that many countermeasures proposed end up failed to prevent the attacks.
\end{itemize}

We consider Traffic Analysis to be one of the most critical security and privacy threat in WSN applications for three reasons:
\begin{enumerate}
	\item Nodes communicates to each others through RF in open environments. It is easier than Internet for adversaries to monitor the traffic.
	\item Nodes are geographically less distant. This provides the opportunity for the adversary to conduct mass surveillance like attacks.
	\item Countermeasures are difficult to implement in constrained devices due to overhead. Many countermeasures are application specific.
\end{enumerate} 

\subsection{Traffic Analysis Attacks} \label{Subsec: Traffic Analysis Attacks}

\subsubsection{Side Channel Attacks against Web Applications}
\cite{WebSideChannel} describes the general idea of Traffic Analysis against web applications. In this paper, a web application is modelled as a stateful system and the packet features being the input and output of the system. The paper introduced how these side channel information can be exploited through examples of encrypted real world websites.
\begin{example}
	The first example is a health record system as shown in \Cref{Fig: HealthRecordSystem}.
	
	\begin{figure}[h!]
		\center
		\includegraphics[width=0.7\textwidth]{fig/WebSideChannelExample1.png}
		\caption{Example Health Record System from \cite{WebSideChannel}}
		\label{Fig: HealthRecordSystem}
	\end{figure}
	
	In this example, the authors demonstrated that according to which tab or alphabet the user has clicked, the server returns a series of  packets with distinguishable lengths and directions. Further more, distinguishable packet traces can also be observed when user types in the input box triggering auto suggestion. As a result, an eavesdropper can deduce the user input simply by looking at the packet features of encrypted traffic.
\end{example}

\begin{example}
	The second vulnerable website is an online taxing service. In this system, the tax application form varies due to the payee's family status. The vulnerability of this website is that users are directed to different pages according to the form they are going to fill, while different pages results into packets of different lengths and directions, allowing an eavesdropper to reveal the family status of the user. The packet features of encrypted traffic again breached the data confidentiality.
\end{example}

%Financial charts Example
\begin{example}
	The third example is an online investment system where financial charts are provided to the users. The vulnerability is that an eavesdropper can distinguish which chart is presented to an user by the size of the chart which is a gif file. 
\end{example}

%Search Keyword Example (briefly, refers to the other one)
\begin{example}
	The last example shows how Traffic Analysis can be applied to attack the key word user provided to a search engine. \cite{SearchAttack} gives a more thorough description of this attack.
\end{example}

\cite{PinpointWeb} extends the work from a leakage detection perspective. Similar to \cite{WebSideChannel}, a web application is modelled as state machine with the user input and packet traces being the input and output respectively. The packet traces are aligned by sequence of packets. A hypothetical DETECT function is then iterated over the positions of packets. For each position, DETECT function computes an information leakage metric by the aligned packets from different traces and returns it as an indicator of potential information leakage at that position. They further instantiated the DETECT function by using Mutual Information of user input and packet features. Finally, they showed that in the experiment done on an example web application, the ACK flag could also be a potential leakage source in addition to packet sizes, where the latter is a widely exploited packet feature in many Traffic Analysis Attacks.

\cite{SearchAttack} implements the Traffic Analysis Attack on search engines described by \cite{WebSideChannel} in more details. It exploits the fact that Google by default enables auto suggestion which responds to each key stroke of user input with the suggest options and preloaded pages. This attack assumes the user input is within a finite dictionary. The attack is done in two steps:

\begin{enumerate}
	\item The first step is the profiling step. The attacker first builds a prefix tree\cite{PrefixTree} for the whole dictionary. For each edge of the prefix tree, which corresponds to a key stroke from parent to child, the attacker associates it with the distribution of server responded packet sizes that is gathered through multiple trials. 
	\item When an user's traffic is captured, the attacker compares the server responses for each user key stroke to the edges in the prefix tree from the root to the leafs. For each comparison, the attacker computes a likelihood and accumulates it through stochastic algorithms. 
\end{enumerate}

Finally, the algorithms outputs a set of keyword guesses of the highest likelihoods. The attack is considered successful if the keyword user typed appears in the guesses. At the end of the paper they showed that their method proofed to be effective in their settings.

\subsubsection{Website Fingerprinting}
%Web site fingerprinting
Website Fingerprinting is a well studied topic in Traffic Analysis Attacks. \cite{WebsiteFingerprint} demonstrates the application scenario as in \Cref{Fig: Application Scenario of Website Fingerprint}. 

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\textwidth]{fig/WebsiteFingerprint.png}
	\caption{Application Scenario of Website Fingerprint by \cite{WebsiteFingerprint}}
	\label{Fig: Application Scenario of Website Fingerprint}
\end{figure}

Tor\cite{Tor} can be considered as an instance of such network. The goal of Website Fingerprint is to identify the website an user is visiting through a secured channel by looking at the traffic features. Its motivation has received a growth in awareness in the cyber security community due to the recent years disputable governmental mass surveillance.

\cite{WebsiteFingerprint} demonstrates the use of machine learning techniques on packet sizes. To be more specifically, the authors conducted a series of experiment in a ``closed world'' setup of 2000 websites, i.e. assuming the user visits only one of 2000 known websites. To fingerprint a website, the attacker first visits the websites gathering the packet traces. These traces are then used as the training set and fed to the classifier. When a user's traffic is captured, the trace is then treated as the test set to predict which website the user has visited. Two classifier are tested in the experiments, namely Jaccard's coefficient and naive Bayes classifier. The results show that Jaccard's coefficient outperformed naive Bayes classifier in most cases. In addition, the authors also measure the affection of time elapsed and argued that these attacks still hold after 4 weeks of profiling. However, considering the fact that the nature of Internet has changed dramatically in the past decade, the last argument might need to be reconsidered.

%Peekaboo
A series of similar Website Fingerprint experiments has been studied by \cite{Peekaboo}, with aspect to the effectiveness of different countermeasures. Comparing to \cite{WebsiteFingerprint}, \cite{Peekaboo} analysed more packet features other than direction and length, including timing information, total bytes, total bytes on each direction, traffic bursts\footnote{A huge amount of traffic that has been transmitted continuously on the same direction.} and bandwidth. Classifiers from previous works are studied in this paper, namely LL classifier from \cite{WebsiteFingerprint}, H classifier from \cite{HClassifier} and P classifier from \cite{PClassifier}, alongside with some other classifiers designated to specific packet features. With respect to the countermeasures, different padding schemes are compared in this paper, including per packet padding, session wide padding and Traffic Morphing which is a sophisticated padding scheme we describe later in the context. In addition to padding schemes which mostly aimed to mitigate the packet length side channel, BuFLO\cite{Peekaboo} is also introduced to mitigate the timing and bandwidth side channels. For the result, the authors reported that all the padding scheme does not provide enough protection against the best classifier which is the P classier. BuFLO does not bring much security either unless used with a drastic overhead to the performance.

\subsubsection{Other Traffic Analysis Attacks}
%Apple iMessage
%SSH attack
%VoIP attack
%Skype Video
In spite of the attacks we mentioned above, there also exists many other Traffic Analysis attacks against different application. \cite{VoIPLanguage} and \cite{VoIPPhrases} demonstrated that the encrypted Voice over IP, VoIP, traffic could leak the language spoken and certain phrases can be detected. \cite{SSHKey} showed that user key stroke could be revealed by packet timing information. \cite{AppleMessage} shows that user's OS, message length, language and several behaviour can be identified through the size of encrypted packets. \cite{Video} showed that certain video event such as ambient change or object movement in a Skype video chat can be observed through the changes in packet features.

\subsection{Traffic Analysis Countermeasures}

Several countermeasure are proposed to counter Traffic Analysis Attacks. 

\subsubsection{Padding}

Padding is the most common countermeasure that intends to mitigate the packet size side channel. \cite{Peekaboo} summarised the most common padding schemes that aims to prevent Traffic Analysis Attacks. Notice that when a padding scheme would pad a packet longer than MTU, it is truncated to MTU instead.

\begin{description}[style=nextline]
	\item[Session Random Padding] 
	All packets in a session padded with the same random value of bytes.
	\item[Packet Random Padding]
	Each packet is padded with a random value of bytes.
	\item[Linear Padding]
	Each packet is padded to a multiple of 128.
	\item[Exponential Padding]
	Each packet is padded to the nearest power of 2.
	\item[Mice-Elephants Padding]
	Each packet is padded to either 128 or MTU.
	\item[Pad to MTU]
	Each packet is padded to MTU.
	\item[Packet Random MTU Padding]
	Each packet is padded to a random number select uniformly between the data length and MTU.
\end{description}

Paddings are relatively easier to implement but the constrained nature of WSN implies that padding might not be appropriate in as it consumes more bandwidth and therefore more energy consumption.

\subsubsection{BuFLO}

Buffered Fixed Length Oubfuscator, BuFLO, is a countermeasure proposed in \cite{Peekaboo}. BuFLO is a ``fool-proof''\cite{Peekaboo} countermeasure that totally ignores the performance issues in practice and designed only to study at what level the Traffic Analysis attacks can be mitigated in setup of experiments in \cite{Peekaboo}. In general, BuFLO only sends identical length packets on a fixed frequency. Application data are queued in a buffer until either at least a packet is filled, or a timeout is reached and the data is sent along with padding. When no data is buffer, BuFLO sends dummy packets contains no application data. This countermeasure intuitively eliminates most of the packet features that could be exploited, but \cite{Peekaboo} reports that it does not achieve a satisfiable protection unless used with impractically huge performance  overhead (nearly 400\% in bandwidth).

\subsubsection{Traffic Morphing}

Traffic Morphing\cite{TrafficMorphing} is another countermeasure against Traffic Analysis. The idea is to mimic the distribution of packet features of one website to another. This is done through truncating or buffering packets and sending dummy packets by sampling from another website. \cite{Peekaboo} reported this countermeasure outperformed the other padding schemes, although neither of them provides a satisfiable protection. This countermeasure is relatively easier to implement on TCP since TCP provides a reliable stream connection. When implementing Traffic Morphing on UDP, the upper layer application must handle the packet reordering problem as well as segmenting the data. Although Traffic Morphing costs less overhead in bandwidth comparing to paddings; nevertheless, it is unlikely to be adopted by WSNs as the constrained devices does not seem to be capable to afford the sampling procedure in this countermeasure.

%HTTPOS
HTTPOS\cite{HTTPOS} is a Traffic Analysis countermeasure implemented on browser that manipulates the underneath TCP connection to control packet size, timing information, web object size and bandwidth. There are two strategies adopted by HTTPOS:
\begin{description}[style=nextline]
	\item[The Diffusion Strategy]
	 Assuming the adversary uses a known training set, HTTPOS modifies the packet features to some value that has not appeared in the training set. \cite{HTTPOS} claims this strategy will force the adversary to random guess the website but this claim is some how contradictory to the concept of Machine Learning.
	\item[The Confusion Strategy]
	As of Traffic Morphing, HTTPOS modifies packet features by sampling from another website.
\end{description}

For the result, \cite{HTTPOS} reported that their approach achieved nearly perfect protection, i.e. the adversary's accuracy of correctly guessing a website has  dropped to 0 in their test set. This is somehow contradictory to the results in \cite{Peekaboo}, even though the classifier are not exactly identical.

\subsubsection{Format Transforming Encryption}

To an extend, \cite{FTE} proposed a different approach that uses Format-Transforming Encryption, FTE, to circumvent Deep Packet Inspection,DPI, which is strongly related to other Traffic Analysis attacks. The general idea is to morph one type of traffic to another type of traffic, e.g. to morph encrypt SSH data to an ordinary HTTP request. Comparing to standard encryption and decryption, FTE additionally defines an Unrank function which encodes the ciphertext to the target format and a Rank function that decodes the ciphertext. FTE is interested in the Traffic Analysis aspect as it could potentially eliminate some packet features by transforming the original packets into a totally different type of packets.

\section{Methodologies in Information Leakage }

%There are many literatures discuss how to detect , quantify or exploit different types of side channel information leakage. 
In this section, we review a few of the methodologies that is developed to detect, exploit or quantify information leakage in different types of side channels. 

\subsection{Machine Learning}
%Different Classifiers
Machine Learning is a widely used technique in analysing information leakage in packet features, especially in Traffic Analysis literatures such as \cite{Peekaboo} \cite{TrafficMorphing} \cite{WebsiteFingerprint} \cite{HClassifier} \cite{PClassifier} and \cite{HTTPOS} we have mentioned above. 

Typically, there are three steps to launch a Machine Learning based Traffic Analysis Attack:

\begin{enumerate}
	%Training set
	\item The adversary collects a set of traces containing the packet features with known secrets. The secret here means the type of information that the adversary attempts to attack, e.g. which website a trace corresponds to. This data set is the training set.
	%Classifier
	\item The training set is then given as the input to an algorithm called classifier. The classifier reads the training set and eventually generates some rules that map the packet features to the secret. 
	%Test set
	\item The test set is the traces captured for an user visiting a website that the adversary attempts to attack. The secrets in the test set is unknown to the adversary. The test set is then analysed by the classifier which in turn returns guesses of the secrets.
\end{enumerate}

This application is a Supervised Learning in Machine Learning terminology.

%Configurable Parameters
Although most Machine Learning based Traffic Analysis Attacks adopts the similar strategy, there are certain configurable parameters that could greatly affect the outcome.

The first configurable is the packet features. Different classifier make use of different packet features, including headers, size and time of each packet and any connection level statistical features that can be computed through them. The adversary may select any subset of the packet features into the training set.

%Classifiers
The second configurable is the classifier. Classifiers are the core to the prediction. They vary in construction,  accuracy, performance and even inputs. We do not give the detailed explanation about the classifiers as it is beyond the scope of this report. 

\Cref{Tbl: Classifiers in Traffic Analysis Literatures} summarises the classifiers used in the literatures we mentioned in \Cref{Subsec: Traffic Analysis Attacks}

\begin{table*}[h!]
	\center
	\resizebox{\textwidth}{!}{%
	\begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Literature}                        & \textbf{Classifier}                                                        & \textbf{Input Packet Features}                                                                                                                                                                                                      & \textbf{Output Guess}                                             \\ \hline
		\cite{WebsiteFingerprint}, \cite{Peekaboo} & Naive Bayes                                                                & (Direction, Length)                                                                                                                                                                                                                 & Website                                                           \\ \hline
		\cite{WebsiteFingerprint}                  & Jaccard's                                                                  & (Direction, Length)                                                                                                                                                                                                                 & Website                                                           \\ \hline
		\cite{HClassifier}, \cite{Peekaboo}        & \begin{tabular}[c]{@{}c@{}}Multnominal Naive Bayes\\ (MNB)\end{tabular}    & (Direction,  Frequency Distribution of Length)                                                                                                                                                                                      & Website                                                           \\ \hline
		\cite{PClassifier}, \cite{Peekaboo}        & \begin{tabular}[c]{@{}c@{}}Support \\ Vector \\ Machine (SVM)\end{tabular} & \begin{tabular}[c]{@{}c@{}}(Direction, Length, Size Marker\cite{PClassifier}, \\ HTML Markers\cite{PClassifier}, Total Bytes, \\ Number Marker\cite{PClassifier}, \\ Percentage Incoming Packet, \\ Number of Packets)\end{tabular} & Website                                                           \\ \hline
		\cite{AppleMessage}                        & Naive Bayes                                                                & Length                                                                                                                                                                                                                              & \begin{tabular}[c]{@{}c@{}}User OS,\\  User Language\end{tabular} \\ \hline
		\cite{Peekaboo}                            & Naive Bayes                                                                & Total Time                                                                                                                                                                                                                          & Website                                                           \\ \hline
		\cite{Peekaboo}                            & VNG++                                                                      & \begin{tabular}[c]{@{}c@{}}Total Time, Total Per-Direction Bandwidth,\\ Traffic Burst\cite{Peekaboo}\end{tabular}                                                                                                                   & Website                                                           \\ \hline
	\end{tabular}
	}
	\caption{Classifiers in Traffic Analysis Literatures}
	\label{Tbl: Classifiers in Traffic Analysis Literatures}
\end{table*}

%Pros & Cons
Machine Learning is a practical and powerful way to detect information leakage over a combined set of side channel information and can be effectively applied in experiments. However, the drawback is that sometimes it is difficult to quantify the leakage by reversing the rules generated by the classifiers.

%Information Theoretic Approaches
\subsection{Information Theoretic Approaches}

Some other literatures studies information leakage from an information theoretic perspective. As explained earlier in \Cref{Subsec: Traffic Analysis Attacks}, \cite{PinpointWeb} detects information leakage from an Information Theoretic approach.

In Information Theory, entropy is the metric that evaluates the uncertainty of a random variable. The entropy\footnote{Specifically, Shannon Entropy.}  of a random variable $X$ is defined as $H(X)$:

\begin{equation} \label{Eq: Entropy}
	H(X) = - \sum_{x \in X}{P(x) \log{P(x)}}
\end{equation}

Higher $H(X)$ indicates higher uncertainty of $X$ and vice versa.

Information is therefore defined as the reduction of entropy. Intuitively, the more information we have with regard to the variable $X$, the less uncertainty it has.

In case of side channel information leakage, we are mostly interested into the information of a secret variable $X$ that is contained in another observable variable $Y$. For example, information of cryptographic key contained in the power trace in Power Analysis attacks and information of website contents contained in packet features, etc. This concept is well captured by Mutual Information, defined as:

\begin{equation} \label{Eq: MI}
	I(X;Y) = H(X) - H(X | Y)
\end{equation}

\Cref{Eq: MI} can be intuitively interpreted as the reduction of the uncertainty of $X$ when given $Y$. As of this project, we are presuming the observable $Y$ to be any traffic feature we can observe in WSNs and $X$ any information of the upper layer application.

In practice, evaluating Mutual Information requires the prior distribution of $X$. This is requirement in some scenarios cannot be met. For example as stated in \cite{PinpointWeb} where $X$ is the user input, the prior distribution may vary due to many factors such as different groups of user. Therefore an alternative, which is Capacity, is used to evaluate the worst case of information leakage over all prior distributions of $X$, i.e. the maximum Mutual Information over all possible prior distribution of $X$. The Capacity $C$ is formally defined as:

\begin{equation} \label{Eq: Capacity}
	C = \sup_{\forall P(X)}{I(X;Y)}
\end{equation}

where $\sup$ represents suprema and $\forall P(X)$ represents all possible distribution of $X$.

\cite{PinpointWeb} applies this strategy on each packet feature at each position of aligned packet traces. As stated in the original paper, this method only detects potential leakage points\footnote{A packet feature at a specific position that leaks information.} but does not directly implies an attack. As a matter of fact, \cite{PinpointWeb} reports that TCP ACK packets is a potential leakage source but there is no known attacks that exploits this feature to our knowledge; instead, \cite{PClassifier} even excluded them from the traces considering them as a purely side effect of the protocol and thus irrelevant to the application data.

As stated by \cite{OneTryGuess}, it is showed by \cite{OneTryGuessOrigin} that mutual information does not cover a scenario that the adversary attempts to guess the secret in one try. Following this concept, \cite{OneTryGuess} quantifies the information leakage in a one trial guess scenario. For consistency, we use the notations revised in \cite{GLeakage}. 

\begin{definition}
	Suppose a secret value $x \in X$. Suppose $\pi$ the prior distribution of $X$ which is known by the adversary $\mathcal{A}$. The Prior Vulnerability $V(\pi)$ is defined as:
	
	\begin{equation}
		V(\pi) = \max_{x \in X}{\pi[x]}
	\end{equation}
	
	Suppose a channel $C$ which encodes $x \in X$ to an observable value $y \in Y$, that is
	
	\begin{equation}
		C[x,y] = P(y | x)
	\end{equation}
	
	The Posterior Vulnerability is then defined as:
	
	\begin{equation}
		V(\pi, C) = \sum_{y \in Y}{\max_{x \in X}{\pi[x]C[x,y]}} 
	\end{equation}
	
\end{definition}

Comprehensively, Prior Vulnerability is the best chance  $\mathcal{A}$ correctly guesses $x$ in one try. Posterior Vulnerability is the same probability but given the knowledge of $y$. Since the best strategy for $\mathcal{A}$

\begin{definition}
	The vulnerabilities are converted to min-entropy by taking negative logarithm:
	
	\begin{eqnarray}
		\begin{aligned}
			H_{\infty}(\pi) &= -\log{V(\pi)} \\
			H_{\infty}(\pi) &= -\log{V(\pi,C)}
		\end{aligned}
	\end{eqnarray}
	
	Similar to Mutual Information, the min-leakage entropy leakage $L(\pi,C)$ is defined as the difference of vulnerabilities induced by $C$:
	
	\begin{equation}
		L(\pi, C) = H_{\infty}(\pi) - H_{\infty}(\pi, C)
	\end{equation}
	
	And corresponding min-capacity which is the worst case of leakage over all $\pi$:
	
	\begin{equation}
		ML(C) = \sup_{\pi}{L(\pi,C)}
	\end{equation}
\end{definition}

Remind that these definitions are defined to model the information leakage where the adversary attempts to guess the secret correctly in one try and hence model a binary scenario, i.e. the adversary either correctly guesses the secret or not. \cite{GLeakage} extends the model by introducing a hypothetical gain function $g$:

\begin{definition}
	The gain function $g(w,x)$ is defined as the advantage the adversary gains on a guess $w$ when the secret is $x$. $g(w,x)$ is constrained by $g(w,x) \in [0,1]$.
\end{definition}

An example of real world implication of gain function could be a Template Attack\cite{TemplateAttack} \cite{PracticalTemplate} where an incorrect but ``relevant'' guess can help the adversary to narrow down the key space.

Following the gain function, \cite{GLeakage} adapts the vulnerabilities to g-vulnerabilities $V_g$ by the advantage can gained by an adversary among all possible guesses $W$:

\begin{eqnarray}
	\begin{aligned}
		V_{g}(\pi, C) &= \max_{w \in W}\sum_{x \in X}{\pi[x]g(w,x)} \\
		V_{g}(\pi, C) &= \sum_{y \in Y}{\max_{w \in W}\sum_{x \in X}{\pi[x]g(w,x)}}
	\end{aligned}
\end{eqnarray}

And thereafter the g-entropy, g-leakage and g-capacity:

\begin{eqnarray}
	\begin{aligned}
		H_{g}(\pi) &= -\log{V_g(\pi)} \\
		H_{g}(\pi) &= -\log{V_g(\pi,C)}\\
		L_g(\pi, C) &= H_{g}(\pi) - H_{g}(\pi, C)\\
		ML_g(C) &= \sup_{\pi}{L_g(\pi,C)}
	\end{aligned}
\end{eqnarray}

Different types of leakage can be modelled by substituting different gain functions. \cite{AddMulGLeakage} studies more algebraic properties of this model.

Above the models, other literatures studies improvements of these models. \cite{EstimateLeakage} proposed a method to estimate the information leakage with Mutual Information utilising Blahut-Arimoto algorithm\cite{Blahut}\cite{Arimoto}. \cite{Continuous} proposes the use of continuous instead of discrete variable to  better model some side channel information.

\subsec{Methods from other Side Channel Attacks}
