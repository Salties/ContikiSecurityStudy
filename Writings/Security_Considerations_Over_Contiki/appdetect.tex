\chapter{Application Detection} \label{Chp: Appdetect}
Similar to website fingerprinting, we try to identify the application running on target note by its traffic. This chapter discusses some general idea without a specific application.

\section{Network Protocol Headers}
Since most information in MAC\footnote{Media Access Control, not to be confused with the cryptographic term Message Authenticate Code.}, IP and UDP headers are related to routing and network maintenance and thus independent except the length fields and CRC\footnote{Cyclic Redundancy Check, a code to detect or correct transmission error}. 

\section{Packet Length}
Packet length is usually the most interested target in traffic analysis. However, packet lengths are also highly application dependant; thus we are not pursuing this topic further without a specific application.

\section{Timing Packet Response}
Unlike web applications where the client and server are usually physically distant, sensor networks can sometimes located in a concentrated area, such as a house which its radius can be less than 10 meters. 

These features theoretically enables one to capture all traffics in such a sensor network. As opposed to the case of Internet where packets are usually timed on the client’s side and thus network latency (RTT\footnote{Round-Trip Time}) must be concerned, being able to capture all traffic in the network provides  much more accurate timing information and hence may be exploited to develop more efficient attacks.

\begin{definition}
In a Request-Response application model, \textbf{RI}, {\bf Response Interval}, is defined as the interval between a request packet being received and its response being sent.
\end{definition}

\begin{example}
\begin{figure}
\centering
{
	\includegraphics[width=\textwidth,]{fig/responsetime.png}
}
\caption{Capture of a ping packet}
\label{fig: ping packet}
\end{figure}

\begin{table}[!]
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
Time (ms) & From (ID) & To (ID) & Length (bytes) & Type          \\ \hline
1961218   & 1         & 2       & 108            & ICMP ECHO \\ \hline
1961222   & 2         & 1       & 5              & 802.15.4 ACK  \\ \hline
1961230   & 2         & 1       & 107            & ICMP ECHO \\ \hline
\end{tabular}
\caption{Packet Features of an ICMP ECHO request and response}
\label{Tbl: ping}
\end{table}

Three packets are marked out in \Cref{fig: ping packet} which forms an instance of ICMP ECHO\cite{rfc1122} (also known as PING) session. The extracted packet features are displayed in \Cref{Tbl: ping}.

\begin{description}
\item[Explanation of the Packets:]\hfill \\
The first packet is an ICMP ECHO request and the third packet being its response. The second packet is a 802.15.4 ACK\footnote{This is an acknowledgement from the receiver that notifies the sender that the packet has been received.} and is thus transparent to the upper ICMP protocol.
\end{description}

From this example we can see that the RI for this PING session is:
\begin{equation*}
1961230 - 1961218 = 12 \text{(ms)}
\end{equation*}

\end{example}

Timing information can be exploited by several attacks, such as \cite{Peekaboo} and \cite{rsatiming}.

We have experimentally measured a RNG\footnote{Random Number Generator} call on Wismote platform in the Cooja simulator is roughly 0.3 ms.

\section{PINGLOAD: PING side-channel for Payload }
Support of ICMP ECHO is required by \cite{rfc1122} and is also enabled in Contiki OS by default. However, our experimental results shows that the response time of these ping packets could potentially be exploited to reveal the application running on target sensor node.

We call such technique {\bf  Application Fingerprinting}.

\subsection{Hypothesis} \label{Sec: pingload hypothesis}
A phenomenon we realised is that when a ping packet arrived while the target node is executing some payload, say reading a sensor or processing data, the PING RI begins to vary comparing to a stable value  when no there is no payload. 

\begin{example}
\begin{figure}
\centering
{
  \includegraphics[width=1\textwidth]{fig/pingri.png}
}
\caption{An example of PING RIs with different payload}
\label{Fig: PINGLOAD RIs}
\end{figure}
\Cref{Fig: PINGLOAD RIs} shows RIs of PING collected in two experiments. The upper half are collected with the target is constantly sleep whilst the lower half occasionally receives a request which triggers the target to call RNG. We can see that the PING RI varies alongside the target is given some payload from this figure.
\end{example}

The data shown in \Cref{Fig: PINGLOAD RIs} suggests that the “plain”, that is without any interference, PING RI is 12 to 13 ms. Further more, those variations of  PING RI is very likely caused by the payload of the target.

This experiment inspired that the distributions of PING RIs might vary according to the payload of target and could possibly considered as an fingerprint of the target’s application. In other word, an adversary could possibly tell whether the target is running a specific application by looking at its PING RIs distribution.

The attack is strait forward:
\begin{description}
\item[Profile sleep RIs]: \hfill\\
The PING RIs for a sleeping node of the same platform can be profiled by pinging a sleeping node. We denote the sleeping profile as $RI_{sleep}$. 

\item[Fingerprint application]: \hfill\\
The adversary collects PING RIs on a profiling node with known application. The profiling node needs to be of the same platform and executing the same code of the target’s. The application fingerprint denotes as: $F_p=\{p_1, p_2, ... , p_n\}$. 

\item[Collect fingerprint of target]: \hfill\\
The adversary then collects the PING RI for the target node by pinging it. We denote the collected data as: $F_t=\{t_1, t_2, ..., t_m\}$.

\item[Extract Featured RIs]: We can remove them from the data sets and keep the PING RIs those has been interfered by the application. We denote the extracted RIs as \textbf{Featured RIs}:
\begin{eqnarray*}
F’_p = \{x | x \in F_p,  x \notin RI_{sleep}\}\\
F’_p = \{x | x \in F_t,  x \notin RI_{sleep}\}
\end{eqnarray*}

Practically speaking, the PING protocol are designed to be responded immediately for diagnosis purpose; hence $RI_{sleep}$ usually has an extremely low variance and its mean is also much less than $F_p$ and $F_t$.

Using the Featured RIs not only provides a better vision of the fingerprint but also removes the error caused by different frequency of the target code being executed, as all the Featured RIs are actually collected when the node is at a non-sleeping state. 

\item[Estimate Distribution (Optional)]: \hfill\\
We then estimate the distributions of $F’_p$ and $F’_t$, denote as $D_p$ and $D_t$. A naive method is to simply use their histograms. An example of such histograms are shown as \Cref{Fig: featuredri_rng}.

\begin{figure}
\center
{
	\includegraphics[width=0.49 \textwidth]{fig/featuredri_rng1.png}
	\includegraphics[width=0.49 \textwidth]{fig/featuredri_rng2.png}
}
\caption{Two examples of RNG’s Featured RIs histogram}
\label{Fig: featuredri_rng}
\end{figure}

\item[Distinguish Distributions]: \hfill\\
Finally we test whether $D_t$ and $D_p$ are the same distribution. An naive way is to compute the correlation of counts of the histograms. We conclude the target node is running the profiled application if $D_t$ and $D_p$ are the same distribution.
\end{description}

Practically speaking, the key point of Application Fingerprinting is to test whether the target’s Featured RIs, i.e. $F’_t$, is sampled from same distribution of the profiled one, i.e. $F’_p$; therefore estimating their distribution might not be necessary for some statistical methods such as t-tests. However as we can see in \Cref{Fig: featuredri_rng}, PING RIs’ distribution are very unlikely to be normalised. Therefore a future work is to find a better distinguishing method than the current naive one.

\subsection{Experiment Result}
We tried our Application Fingerprinting method above on a Cooja simulated Wismote platform with different code. \textbf{In conclusion, the fingerprint appears to be effective for certain circumstances but will tends to result into false positives as the profiled application and target application gets similar to each other.}

To be more specifically, the target node execute some specific code upon receiving an application layer protocol request, similar to CoAP. Further more, all traffic are protected by DTLS with TLS\_PSK\_WITH\_AES\_128\_CCM\_8 ciphersuite. Both intervals of PINGs and the application request are set to some asynchronised value to avoid overflooding the target and to create a ‘more realistic’ simulation.

Everything other than the examined code are the same for all experiments. Two samples are collected independently for each code to simulate a fingerprinting scenario. The histograms are clustered by 5ms.

We examined two classes of codes:
\begin{description}
\item[RNG Calls]: \hfill\\
The target node repeatedly calls RNG for $i$ times. We examined their Featured PING RI for different values of $i$. The reason for picking RNG is that on some platforms where a hardware RNG is provided, the call to it is expected to be similar to a call to a sensor reading which is actually an interrupt. Results are shown in \Cref{Tbl: pingload RNG}.

\item[Arithmetic Operations]: \hfill\\
The target node repeatedly does arithmetic operations, namely addition, multiplication and modular, on two random generated word size integers for 10000 times. This class is particularly interested from a cryptographic point of view as the number of arithmetic operations could potentially developed to key recovering attacks. Results are shown in \Cref{Tbl: pingload arth}.
\end{description}



\begin{table}
\centering
\begin{tabular}{|c|cccc}
\hline
\textit{\textbf{Correlations}} & \multicolumn{1}{c|}{i=50} & \multicolumn{1}{c|}{i=100} & \multicolumn{1}{c|}{i=2500} & \multicolumn{1}{c|}{i=5000} \\ \hline
i=50                           & \textbf{0.988}            & 0.891                      & -0.014                      & -0.033                      \\ \cline{1-1}
i=100                          & 0.891                     & \textbf{0.973}             & -0.025                      & -0.042                      \\ \cline{1-1}
i=2500                         & -0.014                    & -0.025                     & \textbf{0.993}              & -0.035                      \\ \cline{1-1}
i=5000                         & -0.033                    & -0.042                     & -0.035                      & \textbf{0.985}              \\ \cline{1-1}
\end{tabular}
\caption{Correlations for RNG}
\label{Tbl: pingload RNG}
\end{table}

\begin{table}
\centering
\begin{tabular}{|c|ccc}
\hline
\textit{\textbf{Correlations}} & \multicolumn{1}{c|}{+} & \multicolumn{1}{c|}{*} & \multicolumn{1}{c|}{\%} \\ \hline
+                              & \textbf{0.990}         & \textbf{0.990}         & \textbf{0.988}          \\ \cline{1-1}
*                              & \textbf{0.990}         & \textbf{0.989}         & \textbf{0.985}          \\ \cline{1-1}
\%                             & \textbf{0.988}         & \textbf{0.985}         & \textbf{0.984}          \\ \cline{1-1}
\end{tabular}
\caption{Correlations for word arithmetic operations}
\label{Tbl: pingload arth}
\end{table}

\begin{table}[]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{\textit {Correlations}} & +     \\ \hline
i=50         & 0.877 \\ \hline
\end{tabular}
\caption{Correlation for $i=50$ and addition}
\label{Tbl: pingload rng arth}
\end{table}

We also computed the correlation for $i=50$ and addition, as shown in \Cref{Tbl: pingload rng arth}.

The results suggests the following conjectures:
\begin{enumerate}
\item The results for RNG suggests that the fingerprinting is effective for this class of code, as the same code results into nearly perfect correlations ($\geq 0.95$).

\item Even relatively slight changes can be detected, as we can see the correlation dropped to $0.891$ alongside 50 iterations of RNG calls (50 RNG calls take about 1.4ms).

\item The results for arithmetic operations indicates that their  fingerprint are unlikely to be distinguishable. There are two potential causes we have considered:
\begin{enumerate}
\item The differences between these operations are too small to be detected.

\item Experiment methodology error. Since the target node we used during the experiments call RNG twice upon each request to generate two operands whilst the word arithmetic operations have much lighter weigh comparing to RNG at magnitude level; thus the fingerprint is dominated by RNG rather than word arithmetic operations. As a result, we can see that a relatively high correlation can be observed between word addition and 50 RNG calls as shown in \Cref{Tbl: pingload rng arth}.
\end{enumerate}
\end{enumerate}

\subsection{A General Hypothetical Model: Black Box Model}
Although the experiments supports the hypothesis that the variation of PING RIs is relevant to the application, it is not yet clear which factor exactly caused the variations. 

Therefore we suggest that this phenomenon is a result of multi factors instead, including:
\begin{itemize} 
\item Code being executed  and whether it is preemptive or non preemptive, 
\item Memory usage, such as packet buffers, or 
\item Any other hardware/software conditions.
\end{itemize}
It is difficult to verify these factors as many of them requires strict synchronisation between devices and the PING RIs are only showing statistical features.

Therefore we propose the Black Box Model which we hope could support further research.

\begin{definition}
The \textbf{Black Box Model} models the target device as a stateful black box. A \textbf{state}, denotes as $\vec{S}=<\text{factor}_1, \text{factor}_2...>$, is an abstracted vector of multiple factors that could affect PING RIs, such as current code context or memory usage. $\mathbb{D}_{\vec{S}}$ is the distribution of PING RIs when the target node is at state $\vec{S}$.
\end{definition}

We can redefine a state by multiple mutually exclusive substates, $\vec{S}_1$, $\vec{S}_2$ etc. Each sub-state has its own PING RI distribution $\mathbb{D}_{\vec{S}_1}$, $\mathbb{D}_{\vec{S}_2}$ etc. The redefinition process can further more be done recursively.

Notice that since each substate are mutually exclusive; therefore $\mathbb{D}_{\vec{S}}$ is a linear combination of all distributions associated with all the substates of $\vec{S}$, since:
\begin{equation*}
\forall x: Prob(RI = x | \vec{s}=\vec{S}) = \sum_{i=0}^{n}{\big( p_i*Prob(RI = x | \vec{s} = \vec{S}_i)\big)}
\end{equation*}
where $\vec{s}$ is the state at any moment, $p_i$ is $Prob(\vec{s} = \vec{S_i})$ and $n$ is the number of substates of $\vec{S}$.

Hence we can write
\begin{equation} \label{Eq: pD}
\mathbb{D}_{\vec{S}} = \sum_{i}^{n}{\big(p_i * \mathbb{D}_{\vec{S}_i} \big)}
\end{equation}

\begin{example}
Take one of the RNG applications with $i = 5000$ in \Cref{Tbl: pingload RNG} for example. 

We define:
\begin{equation*}
\vec{S}_{main} = <\text{App}=\text{RNG}, i=5000>
\end{equation*}

Its associated PING RI distribution $\mathbb{D}_{\vec{S}_{main}}$ is approximated from the histogram shown in \Cref{Fig: s_main}.

\begin{figure}
\center
\includegraphics[width=0.5\textwidth]{fig/D_S.png}
\caption{PING RIs of $\vec{S}_{main}$}
\label{Fig: s_main}
\end{figure}

We then redefine $\vec{S}_{main}$ to two exclusive sub-states depends on whether the target is in a sleeping mode.
\begin{eqnarray*}
\vec{S}_{main} &&= \vec{S}_{sleep} + \vec{S}_{non-sleep} \\
\vec{S}_{sleep} &&= <\text{App} = \text{RNG}, i = 5000, \text{Code} = \text{sleep}> \\
\vec{S}_{non-sleep} &&= <\text{App} = \text{RNG}, i = 5000, \text{Code} \neq \text{sleep}>
\end{eqnarray*}

Since we know by experiment that the PING RIs are 12 to 13ms when the target is sleep; therefore we can actually approximate $\mathbb{D}_{\vec{S}_{sleep}}$ by filter out those RIs in $[12,13]$. Vice versa,  the distribution of Featured RIs can be viewed as $\mathbb{D}_{\vec{S}_{nonsleep}}$ since they are exactly the RIs filtered by the RIs of sleep. The histograms are shown in \Cref{Fig: s_sleep and s_nonsleep}.

\begin{figure}
\includegraphics[width=0.5\textwidth]{fig/d_sleep.png}
\includegraphics[width=0.5\textwidth]{fig/d_nonsleep.png}
\caption{PING RIs of $\vec{S}_{sleep}$ and $\vec{S}_{nonsleep}$}
\label{Fig: s_sleep and s_nonsleep}
\end{figure}

So we have
\begin{equation} \label{Eq: sleep}
\mathbb{D}_{\vec{S}_{main}} = p_0 \mathbb{D}_{\vec{S}_{sleep}} + p_1 \mathbb{D}_{\vec{S}_{nonsleep}}
\end{equation}
where $p_0$ and $p_1$ corresponds to the probability of the target being sleep and nonsleep.

Solving \Cref{Eq: sleep} gives us roughly $p_0 = 0.538$ and $p_1 = 0.462$. Assuming the PING packets are received by the target randomly, we can estimate that the target is in a sleep for $53.8\%$ of the time and awaken for $46.2\%$.

Theoretically we can further redefine more sub-states, e.g.:
\begin{eqnarray*}
\vec{S}_{nonsleep} &&= \vec{S}_{RNG} + \vec{S}_{header} \\
\vec{S}_{RNG} &&= <\text{App} = \text{RNG}, i = 5000, \text{Code} = \text{random\_rand()}> \\
\vec{S}_{header} &&= <\text{App} = \text{RNG}, i = 5000, \text{Code} = \text{header processing}> 
\end{eqnarray*}

However, obtaining their corresponded distributions poses a problem to this method, we leave this topic to future research.
\end{example}

Practically speaking, $p_i$ might be an interesting information to an  adversary as it reveals the internal state of the target which could lead to many information breach.  In practice, we might only want to approximate the solutions of $p_i$, which effectively reduces the problem of approximating \Cref{Eq: pD} to a knapsack problem\cite{knapsack}.

In most cases obtaining $\mathbb{D}_{\vec{S}_i}$ is difficult. We leave this problem to future research.
