\chapter{Link Layer Security: noncoresec} \label{Chp: LLSEC}

In this chapter, we analysis the Link Layer security measure in Contiki, noncoresec.

One thing to be noticed is that IPv6 fragmentation may affect some packet features. However, as it would be avoided by most of the applications, we assume the packets are not fragmented in this section.

\section{Protocol and Implementation}

\cite{802154sec} has introduced some problems induced by the design of 802.15.4 security, as we has summarised in \Cref{Subsec: 802154 Sec Issue}. Since noncoresec supports only network shared key, we do not consider the key management issues mentioned in \cite{802154sec}. As a result, there are two potential problems left on our platform:

\begin{enumerate}
	\item Nonce reuse
	\item Incompatible anti replay
\end{enumerate}

In this section, we analyse the noncoresec implementation with respect to these two potential problems. The term ``broadcast'' in this section represents Link Layer broadcast.

\subsection{Nonce Reuse}

As we have explained in \Cref{Subsec: 802154 Nonce}, the only variable field in the nonce is Frame Counter. Since noncoresec only supports network shared key. Inspecting the source code, we realised that the Frame Counter is declared as a static value and therefore is initialised to $0$ on each reboot.

Our experiments confirmed the vulnerability. We simulated two executions of  broadcast\_example of keyllsec in \Cref{Sec: Applications}, broadcasting the same message. Our data\cite{NonceReuseData} showed that frames with the same Frame Counter results into the same ciphertext. In reality, this vulnerability implies that an adversary capable to reset the device can eventually learn the difference in plaintext by calculating the difference of ciphertext with the same Frame Counter, causing severe breach of data confidentiality.

One solution might be to store part of the Frame Counter on the flash and increases that value on each time reboot. Assume the device averagely sends one frame every minute stores the highest byte of Frame Counter, it is resilient in $2^8$ reboots and the lower bytes still has the space of $2^{24}$ frames, which holds up to nearly 32 years. Another solution could be to set the higher bytes of Frame Counter to a random value on each reboot. For example, by setting the highest byte to a uniformly distributed random value in $[0,255]$, the adversary is expected to successfully reset the Frame Counter to a specific value with probability of $2^{-8}$ on each reboot.

\subsection{Anti Replay}

\cite{802154sec} has pointed out that anti replay in 802.15.4 Security is incompatible with network key as the same ACL entry is shared among multiple nodes, causing confusion of Replay Counter in ACL. However, with an inspection of the source code of Contiki, we realised that the noncoresec does not suffer the same problem as the ACL is not implemented; instead, a similar data structure is added to the routing table in kernel  associated to each source address.

\section{AES Timing}

As described in \Cref{Subsec: 802154 Sec}, AES-128 is used as the block cipher for 802.15.4 Security. noncoresec uses the AES-128 implementation provided by Contiki system library. The implementation could be either:
\begin{itemize}
	\item An AES-128 coprocessor on the platform.
	\item A software implementation provided in ``/contiki/core/lib/aes-128.c''.
\end{itemize}

The choice of implementation is controlled by the AES\_128\_CONF macro defined in the platform specific configuration file.

Although CC2538 has an AES coprocessor embedded,  the system does not has it supported yet. Therefore we examine the following AES implementations that are used by noncoresec in Contiki release-3.0:
\begin{description}
	\item[AES Coprocessor:] TelosB
	\item[Contiki Software Implementation:] TelosB, CC2538
\end{description}

We assumed AES to be a pseudo random function and uses its output as random numbers in the experiments.

The AES-128 interface provided by Contiki is as described in \Cref{Contiki AES IF}.

\lstinputlisting[label={Contiki AES IF},caption={AES Interface for Contiki release-3.0}]{src/aes_if.c} 

We used the Contiki Real Timer Library\cite{RTimer}, which is a pre-emptive clock library provided by the hardware platform, to measure the system clock ticks of the AES implementations. Each sample measures continuous $n$ rounds executions of AES\_128.encrypt(). The ciphertexts of each round are used as the plaintext for next round.
\Cref{Contiki AES time} shows a simplified code for one sample collection.

\lstinputlisting[label={Contiki AES time},caption={AES Timing on Contiki release-3.0}]{src/aes_timing.c} 

We test this method on  $n \in \{ 50, 100, 150, 200\}$ rounds respectively on random key and plaintext. The result is shown in \Cref{Tbl: AES execution time estimation of Contiki}.

\begin{table}[ht!]
	\center
	\begin{tabular}{|c|c|c|c|}
	\hline
	                               & Ticks (TelosB HW) & Ticks (TelosB SW) & Ticks (CC2538 SW) \\ \hline
	50 rounds                      & 633.57 (ticks)                 & 4565.0                  & 981.31                  \\ \hline
	100 rounds                     & 1270.3                  & 9152.58                 & 1947.6                  \\ \hline
	150 rounds                     & 1901.4                  & 13736.13                & 2913.2                  \\ \hline
	200 rounds                     & 2542.4                  & 18298.92                & 3880.0                  \\ \hline
	Correlation(rounds, ticks)     & 1.000                   & 1.000                   & 1.000                   \\ \hline
        Clock Tick per round & 12.72                   & 91.46                   & 19.33                   \\ \hline
	AES Execution Time   & 388.18 us               & 2791.14 us              & 589.90 us               \\ \hline
	\end{tabular}
	\caption{AES execution time estimation on Contiki, with sample size 100}
	\label{Tbl: AES execution time estimation of Contiki}
\end{table}

Each round is one AES execution and there are $32768$ ticks per second. We estimate the average time of one AES execution by the slope ratio of rounds and ticks.

%Fix vs Random
We apply the Fixed vs Random strategy inspired by TVLA\cite{TVLA} to test the affection induced by using different keys. To be more specifically, we compared $1000$ timing samples collected for $n=200$ on fixed and random inputs to the AES implementations respectively, by using t-test to determine whether a statistical difference can be observed  between two groups. If the null hypothesis, i.e. two groups of timing have the same mean, is rejected, then we conclude there is a potential leakage in the timing information. The timings are assumed to follow a normal distribution.

Theoretically, AES-128 is unlikely to be vulnerable to timing attacks as there is no branch in the algorithm and most of its operations take a constant time; thus the encryption and decryption of a block are expected to take a constant time. Even though \cite{Cache-Timing1} and \cite{Cache-Timing2} described attacks that exploits the timing side channel induced by caching, these attacks are unlikely to be replicable on our platforms as the processors do not have cache implemented. 

The results of our test are shown in \Cref{Tbl: Fixed vs Random test on Contiki AES timing}.

\begin{table}[ht!]
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		              & p-value           & $\overline{t}$ for fixed & $s_{T}$ for fixed & $\overline{t}$ for random & $s_{T}$ for random\\ \hline
		TelosB HW AES & $6.08 * 10^{-5}$  & 2536.9     & 4.77      & 2537.7      & 4.38       \\ \hline
		TelosB SW AES & $5.88 * 10^{-14}$ & 18311.9    & 31.54     & 18293.106   & 36.11      \\ \hline
		CC2538 SW AES & 0                 & 3800.49    & 3.93      & 3878.80     & 2.37       \\ \hline
	\end{tabular}
	\caption{Fixed vs Random test result on Contiki AES timing, with sample size 1000. $\overline{t}$: sample mean of ticks, $s_{T}$: sample standard deviation of ticks}
	\label{Tbl: Fixed vs Random test on Contiki AES timing}
\end{table}

%Not observable from traffic.
The results in \Cref{Tbl: Fixed vs Random test on Contiki AES timing} contradict with our intuition and imply a potential leakage of key in execution time. However, we have not yet came up with any potential cause of this variance. We leave this as an open question in this report.

On the other hand, we also noticed that this timing variance is of tens of clock ticks for $200$ executions. Combing with the fact that there is $32768$ ticks per second, it is equivalent to say for one execution the variance is averagely at $10^{-7}$s level. Even for a 802.15.4 Frame of MTU size which is 127 bytes, there is no more than $8$ AES executions for encryption and $8$ executions for MIC computation. Therefore the variance is expected at $10 ^ {-6}$s level. Since the bit rate of 802.15.4 PHY is at most 250 kb/s\cite{802154}, i.e. at least $3.91 * 10^{-6}$s is needed to transmit a bit, plus there are even more factors such as RDC and CSMA/CA those may affect the timing of packets at a magnitude of $10^{-4}$s level, we suspect that such timing variance would be difficult to observe from the traffic in practice.

%Source code and data
The source code and experiment data are available at:\\
\url{https://github.com/Salties/MyRepository/tree/master/experiments/keyllsec/} \\
and \\
\url{https://github.com/Salties/MyRepository/tree/master/experiments/keyllsec/Data/aestiming}

%\section{Packet Feature Analysis}
%
%In this section, we analyse the general packet features of WSN protected by noncoresec. We focus on the following subjects:
%
%During the experiments, we also realised that the RPL messages can be distinguished in most of our applications by jointly inspect the MAC destination address and frame size, even though it is part of the encrypted MAC Payload.

\section{Frame Size} \label{noncoresec frame size}

As described in \Cref{Subsec: 802154 Sec}, when 802.15.4 Security is enabled, the MAC Frame will have an additional Auxiliary Security Header and MIC. Since no Key Strategy support is implemented and we imposed Security Level $7$ in all our related applications, it is expected that noncoresec will linearly increases the frame size as explained in \Cref{Semantic Packet Size}.

Theoretically, the value of $b$ in \Cref{Eq: Linear Length} for noncoresec is $21$, for $5$ bytes from Auxiliary Header\footnote{Security Level together with Key Strategy are aligned into $1$ byte.} and $16$ bytes from the $128$ bits MIC.

%With broadcast and unicast respectively.
Our Cooja simulation confirmed this conjecture. We have done two groups of experiments on TelosB mote simulator, one with keyllsec broadcast application and the other with unicast application.

An example data is available at: \\
\url{https://github.com/Salties/MyRepository/tree/master/experiments/keyllsec/Data/frame_size}

\subsection{Broadcast}
In case of broadcast without noncoresec, the relation of application data, i.e. UDP Payload, size $l_D$ and plaintext MAC Frame size $l_P$ in bytes are:
\begin{equation}
	l_D = l_{P} - 66
\end{equation}

With noncoresec enabled, the application data size $l^{\prime}_D$ and ciphertext MAC Frame size $l_C$ are:
\begin{equation} \label{Eq: broadcast llsec data size}
	l^{\prime}_D = l_{C} - 87
\end{equation}

Assuming the same application data is sent, i.e. $l_D = l^{\prime}_D$, the change of frame size induced by noncoresec is:
\begin{equation}
	b = l_C - l_P = (l^{\prime}_D + 87) - (l_D + 66) = 21
\end{equation}

\subsection{Unicast}

In case of keyllsec unicast application, we have:

\begin{equation}
	l_D= l_P - 80
\end{equation}

\begin{equation} \label{Eq: unicast llsec data size}
	l^{\prime}_D = l_{C} - 101 
\end{equation}

Therefore, 
\begin{equation}
	b = l_C - l_P = (l^{\prime}_D + 87) - (l_D + 66) = 21
\end{equation}

which is exactly the expected value.

\subsection{Conclusion}

In either cases, the size of additional data induced by noncoresec is $21$ bytes. Specifically, \Cref{Eq: broadcast llsec data size} and \Cref{Eq: unicast llsec data size} can be used to deduce the application data size in frames protected by noncoresec.

\section{ICMPv6 Messages}

ICMPv6 messages are used for IPv6 network maintenance. Specifically, RPL messages are a family of ICMPv6 messages those are directly responsible in forming and maintaining a 6LoWPAN network. ICMP messages are solely handled by the Contiki kernel and are thus transparent to  upper layer applications. Some of them, including RPL messages, are generated spontaneously by the Contiki kernel even when no application is running. We observed three RPL messages in our experiments, which are DIS, DIO and DAO. Four ICMPv6 messages are also observed, namely NS, NA and Echo messages. The semantics of these ICMPv6 messages are described in \Cref{Subsec: ICMPv6}.

In this section, we analyse their packet features in a 6LoWPAN network protected by noncoresec.

\subsection{Packet Size and MAC Destination Address}

In the experiments, we realised most of the ICMPv6 messages observed has distinctive packet features with respect to the combination of packet size and destination address family. We summarise the packet features in \Cref{Tbl: Packet Features of ICMPv6 Messages in 6LoWPAN with noncoresec}, where ``0xffff'' is the Link Layer broadcast address.

\begin{table}[ht!]
	\center
	\begin{tabular}{|c|c|c|}
		\hline
		       & Packet Size (bytes) & 802.15.4 Destination Address \\ \hline
		DIS    & 85                  & 0xffff                       \\ \hline
		DIO(1) & 118                 & 0xffff                       \\ \hline
		DIO(2) & 123                 & unicast                      \\ \hline
		DAO    & 97                  & unicast                      \\ \hline
		NS (1) & 87                  & 0xffff                       \\ \hline
		NS (2) & 87                  & unicast                      \\ \hline
		NA     & 87                  & unicast                      \\ \hline
		ECHO   & 112(*)               & unicast                      \\ \hline
	\end{tabular}
	\caption{Packet Features of ICMPv6 Messages in 6LoWPAN with noncoresec, where 0xffff is the Link Layer broadcast address.}
	\label{Tbl: Packet Features of ICMPv6 Messages in 6LoWPAN with noncoresec}
\end{table}


%\paragraph{Explanation of \Cref{Tbl: Packet Features of ICMPv6 Messages in 6LoWPAN with noncoresec}}
\begin{enumerate}
	\item DIO and NS message can be sent in either multicast or unicast. The broadcast DIO message is smaller than the unicast one as it uses an abbreviated IPv6 multicast address ``ff02::1a''. NS uses another multicast destination address, ``ff02::1:ff00:0'', which has the same length as an unicast address. However, both of them are translated to the same ``ffff'' Link Layer broadcast address in 802.15.4 MAC Header.
	%ICMP ECHO fragmentation in Wismote network.
	\item The size of ICMP ECHO Request and Response may vary due to its payload. On our host machine which runs on Ubuntu 15.04, the default ping command payload is 56 bytes which is expected to result into a frame of 157 bytes, exceeding the MTU required by \cite{802154} and causes fragmentation. The ``-s'' option is therefore used to reduce the size of ICMP ECHO packets. Theoretically, any packet less than 802.15.4 MTU, i.e. 127 bytes, should not be fragmented; however, in our experiments, we realised that ICMP ECHO packets larger than $107$ bytes, i.e. with payload more than $6$ bytes, will be fragmented. We have not identified the exact reason but we consider this might be a bug of implementation.
	%No NS and NA in Sky network.
	\item Different ICMPv6 messages maybe observed on different platforms. In our experiments, there is no NS and therefore NA observed in WSN built with TelosB.
\end{enumerate}

%Less than minimum size ICMP.
Recall \Cref{Eq: broadcast llsec data size} and \Cref{Eq: unicast llsec data size}, when at least one byte is sent, the minimum frame sizes are 88 bytes and 102 bytes for broadcast and unicast respectively; therefore packets with size less than these values can be immediately categorised as non application packets, which are basically ICMPv6 messages in practice. Some ICMPv6 messages are thus can be distinguished, as shown in \Cref{Tbl: Distinguishable ICMP Messages}.

\begin{table}[ht!]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		$<\text{Frame Size}, \text{Destination Address}>$                     & ICMPv6 Message \\ \hline
		\textless85, broadcast\textgreater & DIS            \\ \hline
		\textless87, broadcast\textgreater & NS             \\ \hline
		\textless97, unicast\textgreater   & DAO            \\ \hline
		\textless87, unicast\textgreater   & NS / NA        \\ \hline
	\end{tabular}
	\caption{Distinguishable ICMP Messages}
	\label{Tbl: Distinguishable ICMP Messages}
\end{table}

%NS & NA, DIS & DIO
NA is only sent as a response to NS; therefore if a round trip of two 87 bytes unicast packet is observed, it is likely that the first one is NS and the second NA. Similarly, DIS is sent for requesting DIO messages.  Once a valid DIO is received, the node no longer sends out DIS. Therefore if a sequence of broadcasted 85 bytes frames is terminated by a frame of 118 bytes, they are likely to be DIS and DIO messages.

Other ICMPv6 messages are still possible to be distinguished by \Cref{Tbl: Packet Features of ICMPv6 Messages in 6LoWPAN with noncoresec}, but misidentification may occur if the application happened to send packets of both same size and destination address.

%Full list of ICMP
%Example Data
A list of supported ICMPv6 Messages in Contiki release-3.0 is given in \Cref{Supported ICMPv6}. Some of them not included in \Cref{Tbl: Packet Features of ICMPv6 Messages in 6LoWPAN with noncoresec}, as we did not observe them in our experiments.

Some example data are available at:\\
\url{https://github.com/Salties/MyRepository/tree/master/experiments/keyllsec/Data/RPL}

%CONTINUE FROM HERE
\section{RPL Messages Response Timing}

%Sequence Numbers
%No need to do this any more...
%\section{Application Analysis}

%\section{Packet Forwarding}



%
%Link Layer Security, or LLSEC, is a security measure that implements cryptography at Data Link Layer\footnote{https://en.wikipedia.org/wiki/OSI\_model} which is only above Physical Layer.
%
%Introducing cryptography at a lower level has several benefits. Firstly, more data being encrypted reduces the observable packet features to an adversary, such as SRC\footnote{Source Address} and DST\footnote{Destination Address} field in the IP header which are very likely to be exploited by an adversary. Secondly, authentication at lower level also prevents an active adversary from joining the network which therefore weakens her power. 
%
%On the other hand, imposing cryptography at a lower level also brings more challenge to the design of sensor network architecture. The first problem is its overhead. For example, even for a node that only forwards a packet to its next hop, it must decrypt the whole packet to extract its routing information, and then re-encrypt it before transmission. This is particularly problematic in a mesh wireless sensor network as it could potentially downgrades the performance and causing energy consumption problems. More over, key management is also challenging due to the constrained computational power and power optimised lossy nature of wireless sensor network.
%
%It is noticeable that some packet features are not hidden even with LLSEC enabled, such as packet length, timing information and part of the MAC header in a 802.15.4 packet.
%
%\section{802.15.4 Security: {\it noncoresec}} \label{sec: noncoresec}
%{\it noncoresec}\cite{LLSEC} is the current implementation of LLSEC in Contiki. It implements AES\_CCM\_16 ciphersuite in 802.15.4 standard. This section briefly describes how it works.
%
%\begin{itemize}
%\item {\bf Key Management}: All nodes share a network wide AES key for both encryption and authentication. The key is hardcoded during the setup stage.
%
%\item{\bf AEAD\footnote{Authenticated Encryption with Associated Data}}: {\it noncoresec} implements AES\_CCM\_16 \footnote{CCM mode of AES-128 with 16 bytes MAC} as described in 802.15.4\cite{802154} which turns AES into a stream cipher. The same key is used for both encryption and authentication.
%
%\item{\bf Initial Vector (IV, or nonce)}: The IV for each packet is constructed from certain fields of unencrypted MAC header and therefore is public.
%\end{itemize}
%
%An adversary without the knowledge cannot join the sensor network protected by \textit{noncoresec} as she cannot sent out a valid RPL message.
%
%\section{Weak IV}
%
%\begin{figure}
%\centering
%\begin{tabular}{| l | l | l | l | l |}
%\hline
%Flags(1) & Addresses(8) & Frame Counter(4) & Security Level(1) & Block Counter(2)       \\ \hline
%\end{tabular}
%\caption{IV of 802.15.4 Frame with Security} \label{Tbl: 802154 Frame}
%\end{figure}
%
%One problem within the {\it noncoresec} implementation is the low variance of IV. The IV is a $16$ byte bit-string constitutes of the following fields(\Cref{Tbl: 802154 Frame}):
%\begin{itemize}
%\item {\bf Flags (1 byte)}: This field contains part of the MAC header. It is identical to most (basically all) of the data packets.
%
%\item{\bf Source Address (8 bytes)}: This is mapped from the source address field of the packet.
%
%\item{\bf Frame Counter (4 bytes)}: This field increases by 1 from 0 for each packet sent to prevent replay attack.
%
%\item{\bf Security Level (1 byte)}: This field indicates which ciphersuite to be used for this packet. In the case of AES\_CCM\_16, this is constantly 0x7.
%
%\item{\bf Block Counter (2 bytes)}: This field begins from 0x0 and increases by 0x1 for each block in CCM mode. The block length for AES-128 is 16 bytes. The 2 bytes counter is usually sufficient as it supports up to $2^{32}$ bytes of data whereas the minimum MTU\footnote{Maximum Transmit Unit, simply speaking this is the maximum length of a packet.} required by 6lowPAN standard\cite{rfc4944} is $127$ bytes.
%\end{itemize}
%
%In the current {\it noncresec} implementation, \textbf{Flags} and \textbf{Security Level} are constant. \textbf{Block Counter} always begins from 0x0 and the \textbf{Source Address} is also constant for a specific device. Such design leaves the 4 bytes \textbf{Frame Counter} the only field that is variable. This indicates that only $2^{32}$ messages are allowed without a collision of IV which is cryptographically considered to be inappropriate.
%
%\subsection{Reset Problem}
%The low variance of IV leads to a plaintext leakage problem which only requires the adversary to reboot the target node. 
%
%The idea is that rebooting the device resets the \textbf{Frame Counter} to 0x0; hence once a pair of packets with same \textbf{Frame Counter} is found, the difference of their plaintext can be computed by their ciphertext:
%\begin{equation*}
%\Delta p = c_1 \oplus c_2
%\end{equation*}
%where $\Delta p$ is the difference of plaintexts. $c_1$ and $c_2$ are their ciphertext respectively.
%
%\begin{example}
%\begin{figure*}
%\centering
%{
%	\includegraphics[width=0.9\textwidth,]{fig/resetproblem.png} 
%}
%\caption{Captured packets with {\it noncoresec} enabled} \label{Fig: reset problem}
%\end{figure*}
%
%\Cref{Fig: reset problem} demonstrates some packet captured\footnote{The duplicated packets are caused by the retransmission of ContikiMAC\cite{ContikiMAC}.} with {\it noncoresec} enabled. These packets are captured with a sensor broadcasting a 4 byte integer with left side of \Cref{Fig: reset problem} being $[00000000]_{16}$ and right $[12345678]_{16}$. Marked are the corresponding ciphertexts which are $[00127401]_{16}$ and $[12262279]_{16}$ respectively.
%
%As we can see, the difference of ciphertext is exactly the difference of plaintext:
%\begin{equation}
%\Delta p = [00127401]_{16} \oplus [12262269]_{16} = [12345678]_{16}
%\end{equation}
%\end{example}
%
%\section{Distinctive Packet Length for RPL Packets}
%Some RPL packets are shorter than the minimum length of data packets which can be used to distinguish the packets. Further more, some RPL packets set MAC header flags differently from data packets.
%
%\section{Performance Issue}
%The header overhead with LLSEC enabled is 20 bytes which is relatively a large overhead comparing to the 127 bytes MTU requirement of 6LowPAN standard\cite{rfc4944}.