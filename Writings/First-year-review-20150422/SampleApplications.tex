\chapter{Toys}

In this hello-world set-up, there is only one server and one client connected through local-link. The protocol suit we adopted is: [IPv4 or IPv6] + UDP + DTLS.  

All fiedls of UDP and DTLS header will be analysed.
\\
\textbf{Abbreviations}:
\begin{description}
\item[CLIENT] Client.
\item[SERVER] Server.
\end{description}

For the attack model, we define our adversary as a passive eavesdropper, i.e.
\begin{itemize}
\item The adversary is allowed to use a sniffer to capture all packets transmitted between CLIENT and SERVER.
\item Only DTLS payload is encrypted, all other contents of the packets are captured in plaintext by the adversary.
\item The adversary has specific pre-knowledge for each application, e.g. the set of contents that could be transmitted between CLIENT and SERVER, or some specific behaviour of CLIENT and SERVER.
\end{itemize}

\section{Odd or Even}
\textbf{Odd or Even} is an extremely simple toy application. It is designed to demonstrate the fundamental idea of traffic analysis.

\subsection{Description}
CLIENT randomly generates a 32-bit unsigned integer R and sends it to SERVER. SERVER replies with a string “ODD'' or “EVEN” according to the integer sent(\Cref{Fig: Odd or Even}).

\begin{figure}[H] 
\centering
\resizebox{8cm}{!}
{\input{./Pics/OddOrEven.tex}}
\caption{Description of an Odd-or-Even session}
\label{Fig: Odd or Even}
\end{figure}

\subsection{Analysis [To be completed...]}

For every Odd-or-Even session, 

Packets from CLIENT to SERVER:

All fields for every packet are the same, except:
1. Encrypted Application Data field in DTLS layer.
2. Sequence Number increased by 1 every packet.
3. Checksum in UDP layer.

Packets from SERVER to CLIENT:

All fields are the same for every packet except:
1. Encrypted Application Data field in DTLS layer.
2. Sequence Number increased by 1 every packet.
3. Checksum in UDP layer.
4. Length field in both DTLS layer and UDP layer. The values are always (20,41) respectively when data is "Odd" and (21,42) when data is "Even".

Therefore in this application, given pre-knowledge that server responds with either "Odd" or "Even", the length field in both DTLS layer and UDP layer can directly leak the plaintext. 

\section{Leaky Coffee}

\subsection{Description}
\textbf{Leaky Coffee} simulates the scenario that CLIENT initiates a Leaky-Coffee session with a request to SERVER, SERVER replies with a response and CLIENT then reacts according to the response.

\subsubsection{Syntax}
\begin{definition}
\textit{COFFEE} is a set of strings defined as:\\
 $COFFEE = \{  {\text{"AMERICANO"}}, \text{"CAPPUCCINO"}, \text{"ESPRESSO"}, \text{"MOCHA"}\}$
\end{definition}

\begin{definition}
Let '*' represents SUGAR and '@' represents MILK respectively, we denote $n_*$ and $n_@$ as the number of appearances of '*' and '@' in a string. We also call $n_*$ and $n_@$ the degree of SUGAR and MILK of a string.
\end{definition}

\begin{definition}
We define a set of string \textit{ADDITIVE} as:\\
$ADDITIVE = \{\{ SUGAR, MILK \}^{0 - 6} | 0 \leq n_{*} \leq 3, 0 \leq n_{@} \leq 3 \}$.

In another word, an instance of \textit{ADDITIVE} contains no more than 3 SUGAR and MILK.
\end{definition}

\subsubsection{Leaky-Coffee Session}
A Leaky-Coffee session can be described as in \Cref{Fig: Leaky-Coffee Session}:

\begin{figure}[H]
\centering
\resizebox{10cm}{!}
{\input{./Pics/LeakyCoffee.tex}}
\caption{Description of a Leaky-Coffee session}
\label{Fig: Leaky-Coffee Session}
\end{figure}

\begin{description}
\item[1] As an initiation of a conversation, CLIENT randomly picks a string $Order \in COFFEE$ and sends it to SERVER.

\item[2] Upon receiving an \textit{Order}, SERVER replies with a string $\{Order || Flavour\}$ where $Flavour \in ADDITIVE$ and $||$ represents concatenation. If $Order = \text{"ESPRESSO"}$ then the degrees of both SUGAR and MILK of \textit{Flavour} are set to $0$.

\item[3] CLIENT randomly generates a SUGAR requirement $r_* \in [0, 3]$ and a MILK requirement $r_@ \in [0,3]$. Then it scans the reply from \textbf{2} and computes its degrees of SUGAR and MILK. If any of the degrees does not  met the requirements, i.e. $n_* < r_*$ and/or $n_@ < r_@$, then CLIENT sends a $ FlavourRequest = \{"FLAVOUR"||\{SUGAR\}^{\max({r_* - n_*,0})} || MILK^{\max(r_@ -  n_@, 0)} \} $.

\item[4] If SERVER receives a $FlavourRequest$, it echoes back $FlavourRequest$ as its $FlavourResponse$, i.e. $FlvaourResponse = FlavourRequest$.	
\end{description}

Note that the $FlavourRequest$ and $FlavourResponse$ packets are probabilistic in a Leaky-Coffee Session.

\begin{example}
An example with $FlavourRequest$ and $FlavourResponse$(\Cref{Fig: Leaky-Coffee Example1}):

{
\begin{figure}[H]
\centering
\resizebox{8cm}{!}
{\input{./Pics/LeakyCoffee_example1.tex}}
\caption{Example: A Leaky-Coffee session with $FlavourRequest$ and $FlavourResponse$}
\label{Fig: Leaky-Coffee Example1}
\end{figure}
}
In this example, CLIENT first sends an $Order$ “MOCHA”. SERVER then replies with “MOCHA*@” which implies both the SUGAR degree and MILK degree are $1$. CLIENT randomly generates a SUGAR requirement $3$ and MILK requirement $2$ and then sends a $FlavourRequest$ to request the shorted SUGAR and MILK. SERVER finally response with the requested ADDITIVE.
\end{example}

\begin{example}
Another example without $FlavourRequest$ and $FlavourResponse$(\Cref{Fig: Leaky-Coffee Example2}):

\begin{figure}[H]
\centering
\resizebox{6cm}{!}
{\input{./Pics/LeakyCoffee_example2.tex}}
\caption{Example: A Leaky-Coffee session without $FlavourRequest$ and $FlavourResponse$}
\label{Fig: Leaky-Coffee Example2}
\end{figure}

This example demonstrates a session initiated with “ESPRESSO” where no ADDITIVE will be added in the reply.
\end{example}

\subsubsection{Implementation}
SERVER listens to a fixed port (20220) while CLIENT assigns an ephemeral port during each run, i.e. CLIENT’s port is selected at the beginning of each run and remains constant during the life time of that instance.

In this experimental implementation, all random values are generated by the Linux kernel random number generator(/dev/urandom); thus assumed to be uniformly distributed. 

After each session, CLIENT will be putted into sleep for a random period from 5 to 15 seconds.

We used localloop as our network interface in our experiment; thus packet loss is not considered. DTLS does implement retransmission at some level, but since the sequence number in DTLS header does not change in the retransmitted packet so it is still seemingly possible to reconstruct the equivalent packet stream without any packet loss. Even though the reconstructed stream will preserve all information in each header but the accurate time stamps will be difficult to recover.

\subsection{Analysis [to be completed]}

\subsubsection{Detect Session}
It is obvious that whenever there is a packet transmitted then there 

\subsubsection{Isolate A Session}
Given the implementation, we can isolate a session from the packet stream by analysing their time stamp. 
This is achieved by using a threshold value and then compare it with the interval of two packets. If the interval is greater than the threshold then we can guess these packets belong to different sessions.

\begin{algorithm}[H]
\KwIn{threshold $\theta$, time stamps of two continuous packets $t_1, t_2$}
\KwOut{TRUE if the packets are of the same session, otherwise FALSE}
{
	\eIf{$\theta > \left| t_2 - t_1 \right|$} {
		\Return{TRUE}\;
	}
	{
		\Return{FALSE}
	}
}
\caption{IsSameSession}
\label{1}
\end{algorithm}

In our implementation, a typical guess .By continuously applying \Cref{1} on the duplex packet stream, we can easily isolate different sessions.

\subsubsection{Determine Packets in a Session}
Once a session has been isolated, it this not difficult to identify the type of each packet in \textbf{Leaky Coffee}  as there can only be two types of session:
\begin{enumerate}
\item Session with 4 packets: This type of session can be identified with 4 packets presented. Further more, those packets can be identified sequentially as: $<Order, Order||Flavour, FlavourRequest, FlavourResponse>$ respectively as well.

\item \textbf{Session without \textit{FlavourRequest} and \textit{FlavourResponse}}. 2 packets sessions can be identified as this type of session. Those packets can then be identified as $<Order, Order||Flavour>$ accordingly.
\end{enumerate}

\subsubsection{Guessing Plaintext by One Packet Length}
In this implementation, assume we have the pre-knowledge that each $Order \in COFFEE$ picked by CLIENT has an uniform distribution. Further from, the degree of SUGAR and MILK also have uniform distributions over ${0,1,2,3}$. Given these distributions, it is some how possible to make guesses of the plaintext in the packets by the length given in DTLS header, or UDP header, without trying to break the encryption primitives.

We denote the value of DTLS Length field as $l_D$ and the actual application data length as $l$. Our experiment shows that:
\begin{equation}
l = l_D - 17
\end{equation}
under both IPv4 and IPv6.

\begin{definition}
For a specific packet in a session, let $\mathbb{X}$ be the set of plaintext and $\mathbb{Y}$ be the set of its corresponding content length.

 We model the plaintext  and their corresponding content length (in bytes) as a channel: 
 \begin{center}
 $W(y|x), x \in \mathbb{X}, y \in \mathbb{Y}$.
 \end{center}

And then the inverse of this channel $W^{-1}(x|y)$ can be viewed as the leakage channel of $\mathbb{Y}$.
\end{definition}

In this context, $\mathbb{X}$ is the set of packet content and $\mathbb{Y}$ the set of content length $l$.

\begin{example}
We begin with a simple example: $Order$.

For $Order$ packets, we have:

\begin{table}[H]
\begin{center}
{\input{./Tables/OrderTable1.tex}}
\end{center}
\caption{$Order$ - $l$ Channel and the probabilities of $Order$}
\label{Tbl: Order1}
\end{table}

In this implementation, CLIENT randomly picks \textit{Order} from $COFFEE$; therefore the probability for every value is $1/4$. Since neither DLTS nor the application induces any randomness to the content length therefore it will always be a deterministic value.

Given $W$ and the probability of $Order$, it can then compute the joint distribution of $(Order, l)$ by:
\begin{equation}
(\widehat{W}P)(x,y) = P(x)W(y|x)
\end{equation}

\begin{table}[H]
\begin{center}
{\input{./Tables/OrderTable2.tex}}
\end{center}
\caption{Joint distribution of $(Order, l)$}
\label{Tbl: Order2}
\end{table}

Then it follows the marginal distribution of content length:
\begin{equation}
P(Y=y) = \sum\limits_{x \in \mathbb{X}}{\widehat{W}P(x,y)}
\end{equation}

\begin{table}[H]
\begin{center}
{\input{./Tables/OrderTable3.tex}}
\end{center}
\caption{Marginal distribution of $l$}
\label{Tbl: Order3}
\end{table}

Finally we can construct the leakage channel using Bayes’ theorem:
\begin{equation}
P(x|y) = {{P(x)P(y|x)} \over {P(y)}}
\end{equation}
\begin{table}[H]
\begin{center}
{\input{./Tables/OrderTable4.tex}}
\end{center}
\caption{Leakage channel of $l$ - $Order$}
\label{Tbl: Order4}
\end{table}

An adversary can then “decode” the plaintext using this leakage channel.


[Experiment results should be placed here shortly... $I_{P}(\mathbb{X} : \mathbb{Y})$ from Baikal]
\end{example}

\begin{example}
Using the same principle, it is also possible to apply the same attack on the second packet: $Order || Flavour$.
\end{example}

\subsubsection{Guessing Plaintext Using Joint Packet Length}

\subsubsection{Other Attacks (Future work???)}
Is it feasible to estimate the distribution of plaintext given packet length alongside with other assumptions?
